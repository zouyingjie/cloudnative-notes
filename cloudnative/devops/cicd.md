# CI/CD 最佳实践

CI/CD 指的是 **Continuous Integration（持续集成）** 和 **Continuous Delivery（持续交付）**，从实践来看应该还有 **Continuous Deployment（持续部署）** 这一步。我们先来区分下这三者的区别：

- **持续集成(Continuous Integration)** ：持续集成关注的是将开发人员的代码不断集成到代码库中。为了保证新的代码没有问题，我们需要在开发人员提交代码后，执行代码编译、质量审查、单元测试等操作，如果期间遇到问题需要通知开发人员进行修正，在没有问题后进行构建打包，并将制品（二进制文件、镜像）推送到制品库中。

- **持续交付(Continous Delivery)**：持续交付是将集成后的代码部署到更贴近真实运行环境的「类生产环境」(production-like environments) 中。在这里可以进行更进一步的功能测试、性能压测等。如果有单独的测试团队，通常也是在这个环境进行测试工作。如果测试没有问题，就可以准备自动或者手动部署到生产环境中。

- **持续部署(Continous Deployment)**：在持续交付的基础上，把部署到生产环境的过程自动化。

虽然功能有所不同，但上述三步强调的都是自动化，做到自动化编译构建，自动化测试，自动化审查，自动化部署。我们这里对 CI/CD 的一些最佳实践做简要总结。

## 持续集成原则

1. 需要有**专门的集成服务器**执行 CI 操作。持续集成通常需要执行编译、测试等操作，如果执行频繁对服务器资源的消耗较大，如果和其他服务组件共享服务器，可能会对其他服务组件造成影响。

2. 根据项目需要，集成操作应该支持基于代码变化（比如 push、PR 合并）的自动触发、定时执行以及手动触发。

3. 提交到代码库的代码必须是可以正常运行、符合规范的，这需要在构建过程执行单元测试、代码审查等操作。

4. 必须保证构建最终成功。如果构建过程中出现错误，修复此类错误是**优先级最高的任务**。在修复后需要重新执行构建。

5. 构建后生成的制品需要存入制品库（Maven 仓库、镜像仓库）等，并部署到集成测试环境。

6. 在集成测试环境需要进行一系列的自动化功能测试，测试需要覆盖核心的业务流程以及关键功能点。

7. 可以在集成测试环境运行相关的性能测试，做初步的性能诊断。

8. 相关步骤尽量支持开关控制，从而支持更加灵活的集成操作。

### 编译打包规范

开发人员提交的代码必须是能编译通过并经过代码排查，下面是一些编译打包的规范：

- 编译环境必须是干净的，不能有任何残留的编译产物。
  
- 每次编译都是独立的，应该从代码库拉取最新代码开始。
  
- 尽量使用容器化的编译环境，因为容器化编译环境每次都是重新实例化,是一个纯净的环境。物理机器在多次编译及操作后,可能编译环境变量和版本信息发生了变更。而且容器化后可以隔离环境的不同,按需启动,减少资源占用。

- 对于各类语言，尽量维持统一的编译环境标准，比如使用统一的 Java/Linux 基础镜像。特殊环境需求需要经过申请和审核。

- 所有的编译告警都应该处理，如果确定是正确的，应该通过其他手段去掉告警信息。
  
- 开发人员更了解代码功能及需求，应该尽可能由开发定义自动编译脚本，脚本中如果有编译开关选项，需要明确定义写明注释。

- 编译服务器的资源要足够，避免因资源不足导致的编译失败和任务阻塞。
  
- 对于编译期的依赖下载，比如 mvn、npm 等依赖，必须从官方中央仓库下载。如果有内部私有库，比如使用 Nexus 作为 Maven 私服，需要建立严格的管理制度，确保私有库中的包经过充分测试。

- 编译产物需要存入制品库，制品库可以是 Maven 仓库、镜像仓库等。

### 镜像标记规范

鉴于容器化编译环境的普及，编译产物通常是镜像。为了便于管理和追踪，镜像需要使用合理的命名和标记规范。

Docker 映像由两个部分标识：名称和标记。例如 ``namespace/service-name:1.9.3`` 镜像,``namespace/service-name`` 是其名称，``1.9.3`` 是其标记。如果在构建镜像时没有明确制定标记,则系统默认使用 ``latest`` 标记。

在企业内部，通常可以把 namespace 分给不同的业务域, 以业务域的名称来命名。服务名即服务在服务目录(CMD或配置中心)的名称，而标记代表版本号。

关于标记，通常有以下几种方式进行标记：

**语义化版本控制**

语义化版本控制（Semantic Versioning）是一种常用的版本标记方式，通常格式为 `MAJOR.MINOR.PATCH`。其中：

- `MAJOR`：主版本号，仅在发布了不兼容的 API 修改时递增。
  
- `MINOR`：次版本号，通常在发布了新功能时递增。
  
- `PATCH`：补丁版本号，通常在做了 bug 修复时递增。

后两个版本号的递增必须在不破坏向后兼容性的前提下进行。使用语义化版本控制时：

- 始终使用 ``latest`` 标记最新的稳定版本的镜像，一般每次发布新版本时都会更新 ``latest`` 标记。
  
- X.Y.Z 版本号的镜像可以用来标记特定版本的镜像，方便用户下载和使用。

**Git 哈希标识**

另一种常用的标记方式是使用 Git 提交的哈希值。每次提交都会生成一个唯一的哈希值，可以用来标记镜像。通常格式为 `commit-id`，例如 `abc1234`。这种方式可以快速定位镜像对应的代码提交，方便追踪和回溯。

**混合标记**

如果 CI/CD 流水线支持获取更加丰富的信息，可以考虑使用混合标记的方式。比如版本号、Git 提交哈希、分支和构建时间等信息，也可以通过自定义 label 进行更加精细化的管理。

笔者常用的发布流水线就采用了混合标记的方式，因为每次构建的分支是固定的，因此采用了 ``version-commitID-buildTime`` 格式进行标记。比如``v3.0.0-ae2bb521a-230528161535`` 表示构建的软件版本为 `v3.0.0`，对应的代码提交为 `ae2bb521a`，构建时间为 `2023-05-28 16:15:35`，

### 代码审查规范

代码审查目的在于提高整体代码品质，提前暴露代码中隐藏的风险，对代码采用静态分析工具执行审查已经成为普遍共识。常用工具包括 SonarQube、Checkstyle、PMD 等。

首先开发人员最好在本地的 IDE 中集成相应的审查工具，像 IDEA、VSCode 都有相关的插件，做到在开发时就能发现问题，像笔者自己的 VSCode、IDEA、Goland 等常用 IDE 均集成了 SonarQube for IDE 插件。

其次我们需要将代码审查集成到 CI/CD 流程中，确保每次代码提交都经过审查，并且定期生成审查报告。

代码审查的内容包括但不限于以下几个方面：

- **编程规范**：变量、函数命名规范，缩进，格式、注释等。
- **代码可读性**：命名、注释、代码尺寸、程序逻辑简化、状态控制、统一标准化。
- **可维护性**：抽象（模型、数据和流程）、耦合度、重用性。
- **错误处理**：错误逻辑、分级、处理以及相关的日志报警。
- **安全漏洞**：SQL 注入、输入输出检查、数组越界、敏感信息、外部引用安全性、安全规则和安全漏洞检查等。
- **内存泄露**：是否有范围越界，资源未释放等。
- **性能问题**：语言性能、并发问题、中间件使用、数据库操作 SQL 等。
- **代码重复率**：冗余代码，相同代码的出现频率。
- **测试覆盖率**：关键逻辑的单元测试。

## 持续部署规范

### 部署准备

对于正在运行的生产系统，任何变动都会具有一定的风险，因此在部署前需要做好充分的准备工作。

**1. 发布计划**

发布前最重要的就是要制定一份发布计划，将发布所需的资源、步骤、应对方案以及相关责任人明确到位，一般包含但不限于以下内容：
   - **组件信息**：需要发布更新的服务组件、PR 信息、功能描述等。
  
   - **发布流程**：组件之间有依赖，有的要先发布，有的要后发布，需要明确发布顺序和依赖关系。为此要将整个流程步骤细化，确保每个环节都有明确的责任人和时间节点。
  
   - **时间节点**：要计划好步骤的开始时间以及预期持续时间，尽量在预期时间内完成，以免影响后续的部署工作。
  
   - **checklist**：定义好各个步骤的验收标准，以清单的方式记录留痕，保证验收的完整性和一致性。
  
   - **责任人和复核人**：每个步骤的执行人，如果任务比较重要最好再设置一个复核人，确保任务的顺利完成。
  
   - **决策人**：当流程执行遇到问题且执行责任人无法自行做决定处理时，需要有相关决策人提供进一步的支持工作，比如技术负责人、架构师等。
  
   - **回滚方案**：在发布过程中，如果出现严重问题需要回滚时，必须有明确的回滚方案，包括回滚的步骤、责任人以及回滚后的验证工作。

**2. 依赖资源库**

部署过程中依赖的所有资源必须事先明确并准备好。比如：

- 第三方资源标准库
- 镜像或SDK
- 执行特定任务的脚本

在执行发布前，必须确保所有依赖资源都已准备就绪，并经过充分测试，以避免在发布过程中出现问题。

**3. 复查环境配置**

复查部署环境及配置,包含但不限于以下内容: 
- 操作系统版本
- 内核参数
- Docker镜像版本
- JVM参数

**4. 悲观分析**

事先分析最悲观的的情况下可能出现的问题，并制定相应的应对和折中方案。

### 部署策略

对于大型的、高度复杂的分布式系统，任何小型模块上的测试成功，都不能保证上线后整个系统的运行正常。直接部署作为一种部署方式只是针对于用户不敏感,并且优先级较低的一些功能。很多大型的互联网公司发布都不是一蹴而就，发布完成立即使用的。我们需要构建一系列的发布策略，逐渐发布产品和服务来降低风险。
  
常见的部署策略如下：
![](https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/9e09392d-k8s_deployment_strategies.png =900x600)

#### 停机部署 Recreate

把现有服务停止，部署好新的版本后再对外提供服务。好处是操作简单粗暴，并且在部署过程中不会出现新老版本同时在线的情况，可以保证状态的一致性。但其缺点是停机时间较长，对用户的影响会很大。

在实际操作中应该尽量避免停机部署。一般只有当新版本和老版本完全不兼容时才会考虑使用停机部署，比如数据库表结构的变更。在部署前需要发布停机公告，并且选择用户访问量较低的时段进行部署。


#### 滚动部署 Rolling Update

通过逐个替换现有服务实例，来缓慢发布应用。每部署成功一个或多个实例并可以对外提供服务后，在将旧版本的实例删除下线。

滚动部署好处在于操作方便，尤其是在 Kubernetes 等容器编排平台上，最常用的 Deployment 资源对象本身默认就是滚动部署，这样可以做到不停机升级。但其升级过程中会有两个版本同时对外提供服务，可能会导致预期之外的问题。比如

- 同时有两个版本对外提供服务，用户的请求访问可能会在 A、B 两个版本之间切换导致问题。
- 新版的程序没有在生产环境经过完整的验证就对外提供服务，存在一定的风险。
- 新旧版本同时存在，相关的回滚、依赖处理、流量管理等工作会变得更加复杂。
  
![](https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/cicd-rolling.png =400x300)

#### 蓝绿部署 Blue/Green

蓝绿部署指的有两套一样的生产环境，一个是当前的生产环境（蓝），另一个是预发环境（绿）。我们先在预发环境中进行新版本的部署和测试，确认无误后，在将流量切换到新版本，这通常需要网关组件的配合。

蓝绿部署的好处在于无需停机更新，并且不会出现同时有两个版本在运行的场景，可以在用户无感的情况下进行服务升级。但和停机部署、滚动部署相比，蓝绿部署需要维护两套生产环境，运维成本会相对较高。

![](https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/cicd-blue-green.png =400x300)

#### 灰度部署

灰度部署又叫金丝雀部署，来源是 17 世界英国矿井工人在下井时都会带一只金丝雀，它对瓦斯浓度十分敏感，一旦浓度超标就会停止鸣叫，这样工人们就得到了预警，从而可以及时撤离。

灰度发布指的就是发布这样一个金丝雀版本，并将一部分生产流量切换到该版本，观察其运行情况。通常流量是按比例分配的。例如90% 的请求流向老版本，10% 的流向金丝雀版本。如果发现问题就及时修正；如果没问题就可以逐步扩大新版本的流量，直到彻底替换老版本。

灰度发布多用于某些缺少足够测试的场景，通过将一部分用户切到新版本使用，来测试功能的稳定性和可靠性。对于用户的选择，通常可以有如下选择方式：

- 基于浏览器 Cookie
- 基于查询参数
- 基于地理位置
- 网关白名单
- 随机挑选

![](https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/cicd-canary.png =400x300)

#### A/B 测试

A/B 测试和灰度发布、蓝绿部署类似，但其目的完全不同：

- 蓝绿部署是为了确保服务不停机更新，并且避免出现同时有两个版本在运行的场景。
- 灰度部署是为了更好的验证服务的稳定性和可靠性。
- A/B 测试是同时上线两个版本，然后做相关的对比，通过分析用户行为数据来评估哪个版本更优。

前两者注重服务的稳定性和可靠性，而 A/B 测试注重的是用户体验和功能的优化。像是网站 UI 大改版、关键算法更新等场景，因为不知道是否得到用户的认可，因此往往需要选择 A/B 测试的方式，将一部分用户拉来当“小白鼠”，然后进行数据收集和分析来得出更加科学的结论，然后基于结论做后续的优化和上线。

![](https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/cicd-ab.png =400x350)


#### 影子部署

影子部署和蓝绿部署类似，也是部署一套和生产环境一致的影子环境，区别在于影子服务会运行一段时间。**用户请求到的生产环境的真实流量会被复制到影子环境中进行处理，只是影子环境不做任何的返回。**

![](https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/cicd-shadow.png)


#### 策略选择

在实际项目上线时，具体实际采用哪种方式取决于需求和预算：
- 当发布到开发、测试环境时，停机或者滚动部署是一个好选择，因为干净和快速。
- 当发布到生产环境时，滚动部署或者蓝绿部署通常是一个好选择，但要做好部署后的主流程验收测试。
- 如果应用缺乏测试或者对软件的功能和稳定性影响缺乏信心，那么可以使用金丝雀部署或者A/B测试发布。
- 如果资源充足，可以考虑蓝绿部署。
- 如果对上线的安全性要求极高，可以考虑采用影子部署。
