import{_ as d,r as o,c as a,o as u,b as n,a as t,d as i,e as r}from"./app-C-eiXR-Q.js";const s={},v={href:"https://tech.meituan.com/2017/04/21/mt-leaf.html",target:"_blank",rel:"noopener noreferrer"},p={href:"https://en.wikipedia.org/wiki/Universally_unique_identifier",target:"_blank",rel:"noopener noreferrer"},U={href:"https://datatracker.ietf.org/doc/html/rfc4122",target:"_blank",rel:"noopener noreferrer"},m={href:"https://datatracker.ietf.org/doc/html/rfc9562",target:"_blank",rel:"noopener noreferrer"},b={href:"https://github.com/f4b6a3/uuid-creator",target:"_blank",rel:"noopener noreferrer"},D={href:"https://github.com/cowtowncoder/java-uuid-generator",target:"_blank",rel:"noopener noreferrer"},I={href:"https://github.com/google/uuid",target:"_blank",rel:"noopener noreferrer"},g={href:"https://en.wikipedia.org/wiki/Snowflake_ID",target:"_blank",rel:"noopener noreferrer"},f={href:"https://tech.meituan.com/2017/04/21/mt-leaf.html",target:"_blank",rel:"noopener noreferrer"},k={href:"https://github.com/baidu/uid-generator",target:"_blank",rel:"noopener noreferrer"};function c(q,e){const l=o("ExternalLinkIcon");return u(),a("div",null,[e[26]||(e[26]=n("h1",{id:"分布式唯一-id",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#分布式唯一-id","aria-hidden":"true"},"#"),i(" 分布式唯一 ID")],-1)),n("blockquote",null,[e[1]||(e[1]=n("p",null,"在复杂分布式系统中，往往需要对大量的数据和消息进行唯一标识。如在美团点评的金融、支付、餐饮、酒店、猫眼电影等产品的系统中，数据日渐增长，对数据分库分表后需要有一个唯一 ID 来标识一条数据或消息，数据库的自增 ID 显然不能满足需求；特别一点的如订单、骑手、优惠券也都需要有唯一 ID 做标识。此时一个能够生成全局唯一ID 的系统是非常必要的。",-1)),n("p",null,[n("a",v,[e[0]||(e[0]=i("Leaf——美团点评分布式ID生成系统",-1)),r(l)])])]),e[27]||(e[27]=n("p",null,"本文主要介绍一些常见的分布式唯一 ID 生成方案。",-1)),e[28]||(e[28]=n("h2",{id:"uuid-通用唯一识别码",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#uuid-通用唯一识别码","aria-hidden":"true"},"#"),i(" UUID（通用唯一识别码）")],-1)),n("p",null,[e[5]||(e[5]=i("UUID 是 ",-1)),n("a",p,[e[2]||(e[2]=i("Universally Unique Identifier",-1)),r(l)]),e[6]||(e[6]=i(" 的缩写，其目的是为了满足在分布式系统中，各个节点可以独立的生成唯一标识符，不需要依赖一个中心化的服务来分配 ID。相关设计最早在 1980 年代就已经提出，最终 2005 年在 ",-1)),n("a",U,[e[3]||(e[3]=i("RFC4122",-1)),r(l)]),e[7]||(e[7]=i(" 中被完整定义。2024 年最新的 ",-1)),n("a",m,[e[4]||(e[4]=i("RFC 9562",-1)),r(l)]),e[8]||(e[8]=i(" 发布，新增了 3 个新版本的 UUID 生成算法，取代了 RFC4122。",-1))]),e[29]||(e[29]=t("<p>UUID 本身是一个长度为 128bit 的数字，通常用 32 位长度的 16 进制数字表示。因此其理论上的总数为 2^128，约等于 3.4 x 10^38。也就是说如果每纳秒生成一万个 UUID（每秒 <strong>10 万亿</strong>个），在完全随机版本下，需要 1700 万亿年才能生成完所有的 UUID，妥妥的直到宇宙尽头（宇宙预测寿命为 138 亿年）。</p><p>在实际使用中，生成的 UUID 由 32 个字符和 4 个连字符表示，格式为 <code>8-4-4-4-12</code>，我们一般会在生成后将 <code>-</code> 给替换掉 <code>UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;)</code>。</p><p>RFC 4122 中定义了 5 个版本的 UUID，每个版本的算法不同，应用范围也不同，分别为：</p><ul><li><p><code>Time-based UUID</code>：基于时间的 UUID。通过本机 MAC 地址、时间戳以及a随机数计算出 UUID，格式为 <code>timestamp(60bit)-clock_seq(14bit)-MAC(48bit)</code>，另外还有 4bit 的 version 字段和 2 bit 的 variant 字段。因为使用了 MAC 地址，因此理论上绝对唯一，但 UUID 暴露了 MAC 地址，私密性不够好。</p></li><li><p><code>DCE Security UUID</code>：DCE安全的UUID。和版本一类似，但会将时间戳的前 4 位替换为 POSIX 的 UID 或 GID，实际很少使用。</p></li><li><p><code>UUID from names(MD5)</code>：基于名字的 UUID，通过 MD5(命名空间ID + 名称) 计算出哈希值，该版本可以保证相同输入产生相同输出，但目前 MD5 已经不再安全，容易受到碰撞攻击，现在推荐用 UUIDv5 替代。</p></li><li><p><code>truly random UUID</code>：完全随机 UUID。根据随机数或者伪随机数生成 UUID，这是使用最广泛的版本，JDK 中实现的就是这个版本。</p></li><li><p><code>UUID from names(SHA1)</code>：UUIDv3 的升级版，通过 SHA1(命名空间ID + 名称) 计算出哈希值，该版本可以保证相同输入产生相同输出，安全性相对较高。</p></li></ul><p>RFC9562 又提出了三个新的版本，分别是：</p>",5)),n("ul",null,[e[17]||(e[17]=n("li",null,[n("p",null,[n("code",null,"Time-based UUID"),i("：对 UUIDv1 的升级，对时间戳进行了重排，将时间戳从高到低位有序排列，从而提高了数据库索引性能。")])],-1)),n("li",null,[e[16]||(e[16]=n("p",null,[n("code",null,"Unix Epoch-based UUID"),i("：基于 Unix 时间戳的 UUID，使用当前时间戳（自 1970 年 1 月 1 日以来的毫秒数）作为 UUID 的前 48 位，整体格式为 "),n("code",null,"timestamp(48bit)-version(4bit)-randomA(12bit)-variant(2bit)-randomB(62bit)"),i("。 Version7 是专为现代数据库和分布式系统设计的、基于时间的 UUID 格式。它结合了时间戳和高质量的随机数，从而实现了优秀的排序性和唯一性。")],-1)),n("p",null,[e[12]||(e[12]=i("如果开发者使用的语言生态已经支持 Version7，应该优先使用该版本。以笔者熟悉的 Java 和 Golang 为例，JDK 尚不支持 Version7，但已经有 ",-1)),n("a",b,[e[9]||(e[9]=i("uuid-creator",-1)),r(l)]),e[13]||(e[13]=i("和 ",-1)),n("a",D,[e[10]||(e[10]=i("java-uuid-generator",-1)),r(l)]),e[14]||(e[14]=i(" 开源库支持；Golang 方面 Google 官方的",-1)),n("a",I,[e[11]||(e[11]=i("uuid",-1)),r(l)]),e[15]||(e[15]=i(" 库已经支持。",-1))])]),e[18]||(e[18]=n("li",null,[n("p",null,[n("code",null,"Custom UUID"),i("：自定义 UUID，一种实验性质或供应商特定用途的 UUID，除了 version 和 variant 字段外，其余 122bit 可以自由定义。")])],-1))]),e[30]||(e[30]=t(`<p>下面是使用 Java 和 Golang 生成的 Version4 和 Version7 版本的 UUID 示例：</p><ul><li>Golang 示例</li></ul><div class="language-golang line-numbers-mode" data-ext="golang"><pre class="language-golang"><code>package main

import &quot;github.com/google/uuid&quot;

func main() {
	uuidv4 := uuid.New()
	println(&quot;UUIDv4: &quot; + uuidv4.String())

	uuidv7, _ := uuid.NewV7()
	println(&quot;UUIDv7: &quot; + uuidv7.String())
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>UUIDv4: 496a53aa-e690-4d8f-bf77-316d294e2f81
UUIDv7: 01989e87-e56c-729b-a341-5faa691e4b24
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Java 示例</li></ul><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>
import java.util.UUID;

public class UUIDDemo {
    public static void main(String[] args) {

    	//默认是版本 4，完全随机 ID
    	UUID uuid = UUID.randomUUID();
		// 替换 -
    	System.out.println(uuid.toString().replaceAll(&quot;-&quot;,&quot;&quot;));
	}
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>676a8fee6c1b48028dfc86e2bc35e4fe
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="数据库自增-id" tabindex="-1"><a class="header-anchor" href="#数据库自增-id" aria-hidden="true">#</a> 数据库自增 ID</h2><p>一般在设计数据库表时，一定会有一个 AUTO_INCREMENT=1 的 ID 字段，其本身就是一个表范围的全局唯一 ID。但如果数据量达到一定量级，需要分库分表时，生成的 ID 就会重复，此时一般需要设置自增 ID 的起始值和增长步长，比如 MySQL 提供了两个字段进行设置：</p><ul><li><code>auto_increment_offset</code>：自增 ID 的起始值，默认是 1。</li><li><code>auto_increment_increment</code>：自增 ID 的增长步长，默认是 1。</li></ul><p>比如当通过分库分表拆分为三个数据库时，可以设置如下起始值和步长来实现全局自增 ID 唯一：</p><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/db-uniqueid.png" alt=""></p><p>像数据库的自增 ID、Redis 的 <code>INCR</code> 和 <code>INCRBY</code> 命令，Zookeeper 的 <code>Sequential</code> 节点，都带有自增属性，因此都可以用来实现分布式唯一ID，但这些方案都会对中间件产生依赖。无论是使用的编码复杂度，还是对中间件的高可用性要求，相比其他方案都会有一定的劣势。</p><h2 id="雪花算法" tabindex="-1"><a class="header-anchor" href="#雪花算法" aria-hidden="true">#</a> 雪花算法</h2>`,16)),n("p",null,[n("a",g,[e[19]||(e[19]=i("Snowflake（雪花算法）",-1)),r(l)]),e[20]||(e[20]=i(" 是由 Twitter 提出的分布式唯一 ID 生成方案。其核心思想是将时间戳、机器 ID 和序列号结合在一起，生成一个 64 位的唯一 ID。",-1))]),e[31]||(e[31]=n("p",null,"雪花算法的 ID 结构如下：",-1)),e[32]||(e[32]=n("p",null,[n("img",{src:"https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/twitter-snowflake-unique-id.png",alt:""})],-1)),e[33]||(e[33]=n("ul",null,[n("li",null,"1 个保留位，始终为 0。"),n("li",null,"41 位时间毫秒时间戳，其可用年限大约为 69 年。"),n("li",null,"10 位机器 ID，支持 1024 台机器。还可以继续细分， 5 位给 IDC，5 位给工作机器。"),n("li",null,"12 位序列号，可以表示 2^12 = 4096 个数。因此雪花算法最大支持每毫秒生成 4096 个 ID。")],-1)),e[34]||(e[34]=n("p",null,[i("基于以上字段分布，雪花算法可以"),n("strong",null,"每毫秒在一个数据中心的一台机器上产生4096个有序的不重复的ID"),i("。")],-1)),n("p",null,[e[23]||(e[23]=i("不过因为是时间戳的原因，雪花算法在生成 ID 时需要考虑时钟回拨的问题。如果系统时间发生回拨，可能会导致生成的 ID 重复。因此在使用雪花算法时，需要确保系统时间的准确性。Twitter 的官方实现并没有对其做明确处理，只是简单的报错，这样会导致分布式ID服务短期内不可用。后续的开源方案，像美团的 ",-1)),n("a",f,[e[21]||(e[21]=i("Leaf",-1)),r(l)]),e[24]||(e[24]=i("，百度的 ",-1)),n("a",k,[e[22]||(e[22]=i("UidGenerator",-1)),r(l)]),e[25]||(e[25]=i(" 都对其做了优化，这也是比较常用的两个开源库，在实际工程中如果需要，可以在详细调研后进行选型。",-1))])])}const C=d(s,[["render",c],["__file","uniqueid.html.vue"]]);export{C as default};
