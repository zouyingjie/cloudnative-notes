import{_ as o,r as t,c as l,o as r,a as i,b as n,d as a,e as p}from"./app-C-eiXR-Q.js";const d={},c={href:"https://github.com/hadolint/hadolint",target:"_blank",rel:"noopener noreferrer"};function k(u,s){const e=t("ExternalLinkIcon");return r(),l("div",null,[s[2]||(s[2]=i(`<h1 id="docker-最佳实践" tabindex="-1"><a class="header-anchor" href="#docker-最佳实践" aria-hidden="true">#</a> Docker 最佳实践</h1><p>本篇主要针对 Dockerfile 的编写做实践建议。</p><ol><li><strong>使用一个标准一致的Docker镜像来做程序的编译</strong>。如:</li></ol><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">FROM</span> maven:3.6-jdk-8-alpine</span>
<span class="token instruction"><span class="token keyword">WORKDIR</span> /app COPY ./src</span>
<span class="token instruction"><span class="token keyword">RUN</span> mvn -e -B package</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><strong>在 Docker 17.05 以上版本后，尽可能使用 Multi-stage 技术进行构建。</strong></li></ol><p>多个 FROM 指令并不是为了生成多根的层关系，最后生成的镜像，仍以最后一条 FROM 为准，之前的 FROM 会被抛弃。虽然最后生成的镜像只能是最后一个阶段的结果，但是能够将前置阶段中的文件拷⻉到后边的阶段中。这样可以减少所构建镜像的大小以及文件层数。</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">FROM</span> maven:3.6-jdk-8-alpine</span>
<span class="token instruction"><span class="token keyword">WORKDIR</span> /app</span>
<span class="token instruction"><span class="token keyword">COPY</span> ./src</span>
<span class="token instruction"><span class="token keyword">RUN</span> mvn -e -B package</span>

<span class="token instruction"><span class="token keyword">FROM</span> openjdk:8-jre-alpine</span>
<span class="token instruction"><span class="token keyword">COPY</span> <span class="token options"><span class="token property">--from</span><span class="token punctuation">=</span><span class="token string">builder</span></span> /app/target/app.jar /</span>
<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">&quot;java&quot;</span>, <span class="token string">&quot;-jar&quot;</span>, <span class="token string">&quot;/app.jar&quot;</span>]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li><strong>使用 <code>.dockerignore</code>文件</strong></li></ol><p>在大多数情况下，最好把 Dockerfile放在一个空目录里，把构建Dockerfile 需要的文件追加到该目录中。为了改进构建性能。也可以增加一个 .dockerignore 文件来排除文件和目录。该文件支持与 .gitignore 类似的排除模式。</p><ol start="4"><li><strong>避免安装不需要的包和数据</strong></li></ol><p>为了减少复杂性、依赖文件大小和构建时间，我们应该避免仅仅因为他们很好用而安装一些额外或者不必要的包。例如不需要在一个数据库镜像中包含一个文本编辑器。</p><p>比如如果使用 <code>apt-get install</code> 类似的命令，需要相关的缓存。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token parameter variable">-y</span> <span class="token function">install</span> <span class="token punctuation">..</span>. <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> <span class="token parameter variable">-rf</span> /var/lib/apt/lists/*
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="5"><li><strong>尽量减少Docker镜像中的文件层数</strong></li></ol><p>对于Dockerfile中，RUN、COPY和ADD三个命令会创建新的文件层， 所以可以使用 <strong>&amp;&amp;</strong> 来一次运行多个命令(永远将 RUN apt-get update 和 apt-get install 组合成一条 RUN 声明)；使用通配符来一次添加多个文件等。</p><ol start="6"><li>WORKDIR 中使用绝对路径</li></ol><p>为了 Dockerfile 的清晰性和可靠性，我们在 WORKDIR 中应该使用绝对路径。另外如果有类似于 \`RUN cd ... &amp;&amp; do-something\`\` 这样的指令，使用相对目录会导致后续难以阅读和维护，因此应该使用绝对路径替代。</p><ol start="7"><li><strong>使用标签(label)来标记镜像</strong></li></ol><p>Docker 提供标签(labels)来协助通过项目组织镜像，记录授权信息，帮助自动化。每一个标签都以 LABEL 开头并且跟着一对或多对键值对。一个镜像可以包含多个标签，但建议将多个标签放入到一个 LABEL 指令中，可以减少镜像层数。</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">LABEL</span> maintainer=<span class="token string">&quot;yingjie.zou@example.com&quot;</span> <span class="token operator">\\</span>
      version=<span class="token string">&quot;1.0&quot;</span> <span class="token operator">\\</span>
      description=<span class="token string">&quot;示例镜像&quot;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="8"><li><strong>尽量使用官方基础镜像</strong></li></ol><p>无论何时尽可能使用当前官方仓库镜像作为你的基础镜像。Docker官方推荐 Debian镜像，因为它被严格控制并且保持最小(目前小于5MB),同时是一个完整的发行版。当然,如果需要一个 Java的运 行环境,最好的方式是 <code>FROM openjdk</code> 而不用 FROM debian 后再安装 openjdk。</p><ol start="9"><li><strong>尽可能指定特定版本的基础镜像</strong></li></ol><p>比如使用 <code>FROM openjdk:8</code> 而不是 <code>FROM openjdk:latest</code>。</p><ol start="10"><li><strong>尽可能使用最小尺寸的基础镜像</strong></li></ol><p>比如: openjdk:8 有 624MB,而 openjdk:8-jre-alpine 只有83MB</p><ol start="11"><li><strong>ENTRYPOINT 启动脚本</strong></li></ol><p><code>ENTRYPOINT</code> 可以设置镜像的主命令，推荐使用一个脚本来实现程序的启动。比如 <code>ENTRYPOINT [&quot;/entrypoint.sh&quot;]</code>。</p><ol start="12"><li><strong>使用 hadolint 来检查你写的Dockerfile</strong></li></ol>`,29)),n("p",null,[n("a",c,[s[0]||(s[0]=a("hadolint",-1)),p(e)]),s[1]||(s[1]=a(" 是一个用于检查Dockerfile的工具，可以帮助你发现潜在的问题和不符合最佳实践的地方。",-1))]),s[3]||(s[3]=n("ol",{start:"13"},[n("li",null,[n("p",null,[n("strong",null,"不要在 Dockerfile 中写入任何的私密信息,比如:密码或私钥。")])]),n("li",null,[n("p",null,[n("strong",null,"使用非 root 用户执行")])])],-1)),s[4]||(s[4]=n("p",null,"如果某个服务不需要特权执行,建议使用 USER 指令切换到非 root 用户。先在 Dockerfile 中使用类似 RUN groupadd -r postgres && useradd -r -g postgres postgres 的指令创建用户和用户组。避免使用 sudo",-1)),s[5]||(s[5]=n("ol",{start:"15"},[n("li",null,[n("strong",null,"一个容器打包一个应用")])],-1))])}const v=o(d,[["render",k],["__file","docker.html.vue"]]);export{v as default};
