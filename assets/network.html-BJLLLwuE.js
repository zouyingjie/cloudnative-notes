import{_ as i,r as p,c as o,o as r,a as l,b as s,d as a,e as t}from"./app-C-eiXR-Q.js";const c={},d={href:"https://maxnilz.com/docs/004-network/006-linux-rx-v0/",target:"_blank",rel:"noopener noreferrer"},u={href:"https://www.netfilter.org/",target:"_blank",rel:"noopener noreferrer"},v={href:"https://www.teldat.com/blog/en/nftables-and-netfilter-hooks-via-linux-kernel/",target:"_blank",rel:"noopener noreferrer"},b={href:"https://en.wikipedia.org/wiki/Iptables#:~:text=iptables%20allows%20the%20system%20administrator,traversing%20the%20rules%20in%20chains",target:"_blank",rel:"noopener noreferrer"},k={href:"https://en.wikipedia.org/wiki/Netfilter#Connection_tracking",target:"_blank",rel:"noopener noreferrer"},m={href:"https://commons.wikimedia.org/wiki/File:Netfilter-packet-flow.svg",target:"_blank",rel:"noopener noreferrer"},g={href:"https://www.netfilter.org/projects/ipset/index.html",target:"_blank",rel:"noopener noreferrer"},f={href:"https://en.wikipedia.org/wiki/TUN/TAP",target:"_blank",rel:"noopener noreferrer"},h={href:"https://man7.org/linux/man-pages/man4/veth.4.html",target:"_blank",rel:"noopener noreferrer"},P={href:"https://en.wikipedia.org/wiki/Software-defined_networking",target:"_blank",rel:"noopener noreferrer"},y={href:"https://trac.gateworks.com/wiki/linux/vlan",target:"_blank",rel:"noopener noreferrer"},x={href:"https://datatracker.ietf.org/wg/nvo3/about/",target:"_blank",rel:"noopener noreferrer"},S={href:"https://github.com/containernetworking/cni",target:"_blank",rel:"noopener noreferrer"},E={href:"https://github.com/containernetworking/cni/blob/260917dab05ca7352c90c97a3537f8c808aa56b2/libcni/api.go#L103C1-L125C2",target:"_blank",rel:"noopener noreferrer"},N={href:"https://medium.com/@muppedaanvesh/a-hands-on-guide-to-kubernetes-endpoints-endpointslices-%EF%B8%8F-1375dfc9075c",target:"_blank",rel:"noopener noreferrer"},T={href:"https://metallb.universe.tf/",target:"_blank",rel:"noopener noreferrer"},A={href:"https://kubernetes.io/blog/2018/07/09/ipvs-based-in-cluster-load-balancing-deep-dive/",target:"_blank",rel:"noopener noreferrer"},I={href:"http://www.austintek.com/LVS/LVS-HOWTO/HOWTO/LVS-HOWTO.filter_rules.html",target:"_blank",rel:"noopener noreferrer"},C={href:"https://www.tigera.io/blog/comparing-kube-proxy-modes-iptables-or-ipvs/",target:"_blank",rel:"noopener noreferrer"},R={href:"https://kubernetes.github.io/ingress-nginx/deploy/",target:"_blank",rel:"noopener noreferrer"};function U(L,n){const e=p("ExternalLinkIcon");return r(),o("div",null,[n[52]||(n[52]=l('<h1 id="网络原理" tabindex="-1"><a class="header-anchor" href="#网络原理" aria-hidden="true">#</a> 网络原理</h1><p>Kubernetes 最复杂的部分应该是网络和存储，本篇我们介绍下网络的相关知识，对基于 Flannel 和 Calico 插件的网络通信原理做简要分析。</p><h2 id="网络基础概念" tabindex="-1"><a class="header-anchor" href="#网络基础概念" aria-hidden="true">#</a> 网络基础概念</h2><h3 id="linux-network-stack" tabindex="-1"><a class="header-anchor" href="#linux-network-stack" aria-hidden="true">#</a> Linux Network Stack</h3><p>Linux 网络栈示例如下，其符合 TCP/IP 网络模型以及 OSI 模型的理念，网络数据包在链路层、网络层、传输层、应用层之前逐层传递、</p><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/250827-network-stack.png" alt=""></p>',6)),s("p",null,[s("a",d,[n[0]||(n[0]=a("图片来源",-1)),t(e)])]),n[53]||(n[53]=s("h3",{id:"netfilter",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#netfilter","aria-hidden":"true"},"#"),a(" Netfilter")],-1)),s("p",null,[s("a",u,[n[1]||(n[1]=a("Netfilter",-1)),t(e)]),n[2]||(n[2]=a(" 是 Linux 内核提供的一个框架，它允许以自定义处理程序的形式实现各种与网络相关的操作。 Netfilter 为数据包过滤、网络地址转换和端口转换提供了各种功能和操作，这些功能和操作提供了引导数据包通过网络并禁止数据包到达网络中的敏感位置所需的功能。",-1))]),n[54]||(n[54]=s("p",null,"简单来说，netfilter 在网络层提供了 5 个钩子（hook），当网络包在网络层传输时，可以通过 hook 注册回调函数来对网络包做相应的处理，hook 如图所示：",-1)),n[55]||(n[55]=s("p",null,[s("img",{src:"https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/n8s-network-01.png",alt:"在这里插入图片描述"})],-1)),s("p",null,[n[4]||(n[4]=a("图片来自 ",-1)),s("a",v,[n[3]||(n[3]=a("Connecting some of the dots between Nftables, Iptables and Netfilter",-1)),t(e)])]),n[56]||(n[56]=l('<p>Netfilter 提供的 5 个 hook 分别是：</p><ul><li><p><strong>​​PreRouting</strong>：路由前触发。设备只要接收到数据包，无论是否真的发往本机，都会触发此hook。一般用于目标网络地址转换（Destination NAT，DNAT）。</p></li><li><p><strong>Input</strong>：收到报文时触发。报文经过 IP 路由后，如果确定是发往本机的，将会触发此hook，一般用于加工发往本地进程的数据包。</p></li><li><p><strong>Forward</strong>：转发时触发。报文经过 IP 路由后，如果确定不是发往本机的，将会触发此 hook，一般用于处理转发到其他机器的数据包。</p></li><li><p><strong>Output</strong>：发送报文时触发。从本机程序发出的数据包，在经过 IP 路由前，将会触发此 hook，一般用于加工本地进程的输出数据包。</p></li><li><p><strong>PostRouting</strong>：路由后触发。从本机网卡出去的数据包，无论是本机的程序所发出的，还是由本机转发给其他机器的，都会触发此hook，一般用于源网络地址转换（Source NAT，SNAT）。</p></li></ul><p>Netfilter 允许在同一个 hook 处注册多个回调函数，在注册回调函数时必须提供明确的优先级，多个回调函数就像挂在同一个 hook 上的一串链条，触发时按照优先级从高到低进行激活，因此钩子触发的回调函数集合就被称为“回调链”（Chained Callback)。</p><p>Linux 系统提供的许多网络能力，如数据包过滤、封包处理（设置标志位、修改 TTL等）、地址伪装、网络地址转换、透明代理、访问控制、基于协议类型的连接跟踪，带宽限速，等等，都是在 Netfilter 基础之上实现，比如 XTables 系列工具， iptables ，ip6tables 等都是基于 Netfilter 实现的。</p><h3 id="iptables" tabindex="-1"><a class="header-anchor" href="#iptables" aria-hidden="true">#</a> iptables</h3>',5)),s("p",null,[s("a",b,[n[5]||(n[5]=a("iptables",-1)),t(e)]),n[6]||(n[6]=a(" 是 Linux 自带的防火墙，但更像是一个强大的网络过滤工具，它在 netfilter 的基础上对回调函数的注册做了更进一步的封装，使我们无需编码，仅通过配置 iptables 规则就可以使用其功能。",-1))]),n[57]||(n[57]=s("p",null,"iptables 内置了 5 张规则表如下：",-1)),s("ul",null,[s("li",null,[s("p",null,[n[8]||(n[8]=s("strong",null,"raw 表",-1)),n[9]||(n[9]=a("：用于去除数据包上的",-1)),s("a",k,[n[7]||(n[7]=a("连接追踪机制",-1)),t(e)]),n[10]||(n[10]=a("（Connection Tracking）。",-1))])]),n[11]||(n[11]=l("<li><p><strong>mangle 表</strong>：用于修改数据包的报文头信息，如服务类型（Type Of Service，ToS）、生存周期（Time to Live，TTL）以及为数据包设置 Mark 标记，典型的应用是链路的服务质量管理（Quality Of Service，QoS）。</p></li><li><p><strong>nat 表</strong>：用于修改数据包的源或者目的地址等信息，典型的应用是网络地址转换（Network Address Translation），可以分为 SNAT（修改源地址） 和 DNAT（修改目的地址） 两类。</p></li><li><p><strong>filter 表</strong>：用于对数据包进行过滤，控制到达某条链上的数据包是继续放行、直接丢弃或拒绝（ACCEPT、DROP、REJECT），典型的应用是防火墙。</p></li><li><p><strong>security 表</strong>：用于在数据包上应用SELinux，这张表并不常用。</p></li>",4))]),n[58]||(n[58]=l('<p>上面5个表的优先级是 raw→mangle→nat→filter→security。在新增规则时，需要指定要存入到哪张表中，如果没有指定，默认将会存入 filter 表。另外每个表能使用的链也不同，其关系如图所示：</p><table><thead><tr><th>Tables\\Chains</th><th>PREROUTING</th><th>INPUT</th><th>FORWARD</th><th>OUTPUT</th><th>POSTROUTING</th></tr></thead><tbody><tr><td>raw</td><td>✅</td><td>❌</td><td>❌</td><td>✅</td><td>❌</td></tr><tr><td>mangle</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>nat(source)</td><td>❌</td><td>✅</td><td>❌</td><td>❌</td><td>✅</td></tr><tr><td>nat(destination)</td><td>✅</td><td>❌</td><td>❌</td><td>✅</td><td>❌</td></tr><tr><td>filter</td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td>security</td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>❌</td></tr></tbody></table><p>Tables 里列有由上到下代表的 table 的执行顺序，由此我们可以得出处理网络包时，iptables 规则执行顺序：</p><ul><li><strong>发送到本机的包：</strong> <code>PREROUTING(raw, mangle, dnat) -&gt; INPUT(mangle, filter, security, snat)</code></li><li><strong>本机路由到其他机器的包：</strong> <code>PREROUTING(raw, mangle, dnat) -&gt; FORWARD(mangle, filter, security) -&gt; POSTROUTING(mangle, snat)</code></li><li><strong>本地发送到其他机器的包：</strong> <code>OUTPUT(raw, mangle, dnat, filter, security) -&gt; POSTROUTING（mangle, snat）</code></li></ul><p>整理流程如图所示： <img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/iptables-002.png" alt="在这里插入图片描述"></p>',5)),s("p",null,[n[13]||(n[13]=a("图片来自 ",-1)),s("a",m,[n[12]||(n[12]=a("Netfilter packet flow",-1)),t(e)])]),n[59]||(n[59]=s("p",null,"netfilter 和 iptables（以后会还会引入 nfttables）是 kube-proxy 实现基础，通过 ClusterIP 实现由 Service 到 Pod 的通信就是通过 iptables 实现的，本篇后续将详细介绍其通信过程。",-1)),n[60]||(n[60]=s("h3",{id:"ipset",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#ipset","aria-hidden":"true"},"#"),a(" IPSet")],-1)),s("p",null,[s("a",g,[n[14]||(n[14]=a("IPSet",-1)),t(e)]),n[15]||(n[15]=a(" 是 Linux 内核提供的 iptables 配套工具，其允许通过 ipset 命令设置一系列的 IP 集合，并针对该集合设置一条 iptables 规则，从而解决了 iptables 规则过多的问题。这样可以带来如下的一些好处：",-1))]),n[61]||(n[61]=s("ul",null,[s("li",null,[s("p",null,"存储多个 IP 和端口，然后只创建一条 iptables 规则就可以实现过滤、转发，维护方便。")]),s("li",null,[s("p",null,"IP 变动时可以动态修改 IPSet 集合，无需修改 iptables 规则，提升更新效率。")]),s("li",null,[s("p",null,"进行规则匹配时，时间复杂度由 O(N) 降为 O(1)。")])],-1)),n[62]||(n[62]=s("h3",{id:"网络虚拟化",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#网络虚拟化","aria-hidden":"true"},"#"),a(" 网络虚拟化")],-1)),n[63]||(n[63]=s("h4",{id:"虚拟网卡-veth",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#虚拟网卡-veth","aria-hidden":"true"},"#"),a(" 虚拟网卡：veth")],-1)),s("p",null,[n[18]||(n[18]=a("Linux 内核支持两种虚拟网络设备的方案 ",-1)),s("a",f,[n[16]||(n[16]=a("TUN/TAP",-1)),t(e)]),n[19]||(n[19]=a(" 和 ",-1)),s("a",h,[n[17]||(n[17]=a("Veth(Virtual Ethernet，虚拟以太网)",-1)),t(e)]),n[20]||(n[20]=a("，容器主要是基于 Veth 设备实现网络通信的，因此我们这里只对 Veth 做简单介绍。",-1))]),n[64]||(n[64]=l(`<p>使用过网线的同学应该体验过，当我们电脑要联网时，需要将网线的一头插到电脑，另一头插到网孔上。veth 又称为虚拟以太网对（Virtual Ethernet Pair），它就像一根网线一样有两个头，从一个头进来的数据包会直接从另一个头出去。它是在 2.16 版本和网络命名空间一块引入的，旨在解决不同网络 namespace 之间的通信。</p><p>两个不同的容器就是两个不同的网络 namespace，veth 就是那根“网线”，一头在这个容器，另一头在另一个容器中，这样两个容器就可以通过 veth 进行通信了，具体细节我们后续会分析。</p><h4 id="虚拟交换机-bridge" tabindex="-1"><a class="header-anchor" href="#虚拟交换机-bridge" aria-hidden="true">#</a> 虚拟交换机：bridge</h4><p>在物理机网络环境中，如果物理机器较多，每台机器都要单独配置网络的话，管理起来会非常的麻烦，因此引入了交换机，通过交换机将同一网络内的物理机连接起来，实现互相通信。</p><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/250827-network-switch.png" alt=""></p><p>到了虚拟环境，如果容器较多，需要配置的 veth 对的数量也会急剧增加，因此为了方便管理，自然而然我们也需要一个类似交换机的角色。Linux 2.2 版本就引入了名为 Linux Bridge 的虚拟设备充当二层转发设备，工作机制和物理交换机基本一致。当数据进入 Linux Bridge 时，其根据二层 Frame 的帧类型和目的 MAC 地址做相应处理：</p><ul><li>如果是广播帧：转发给所有接入网桥的设备。</li><li>如果是单播帧：查找地址转发表（Forwarding Database），找到目标设备。 <ul><li>如果目标设备存在，转发到目标设备。</li><li>如果目标设备不存在，则洪泛（flood）到所有接入网桥的设备，将响应信息加到自己的地址转发表中。</li></ul></li></ul><p>Linux 最初提供了 <code>brctl</code> 命令来管理 Linux Bridge，但很多新发行版里 brctl 已被淘汰，更推荐用 iproute2 工具（内置，不需要额外安装）来管理，下面是命令示例，后面介绍容器网络通信时还会看到更多操作 veth 和 bridge 的命令。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># 添加网桥
$ sudo ip link add name br0 type bridge

# 查看网桥
$ sudo ip link show type bridge
3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default
    link/ether ce:42:63:b6:d8:9c brd ff:ff:ff:ff:ff:ff

10: br0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether 36:fd:3f:5e:f4:52 brd ff:ff:ff:ff:ff:ff
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="虚拟网络通信-vxlan" tabindex="-1"><a class="header-anchor" href="#虚拟网络通信-vxlan" aria-hidden="true">#</a> 虚拟网络通信：VXLAN</h4><p>有了物理层的 veth 和基于二层通信的 Linux Bridge，容器网络已经能够轻松的实现本机通信。但如果想在更大规模的分布式系统中进行通信，还需要更高层级的虚拟化才行，否则依赖于物理主机的网络互联在当今时代已经变得不够灵活。</p>`,11)),s("p",null,[n[22]||(n[22]=a("为了解决远程物理网络间的灵活通信问题，人们提出了 ",-1)),s("a",P,[n[21]||(n[21]=a("软件定义网络（Software Defined Network，SDN）",-1)),t(e)]),n[23]||(n[23]=a(" 的理念，其核心思想就是在物理网络之上，通过软件构建出一层虚拟化的网络，从而实现灵活的信息通信和流量控制。被构建出来的网络结构中，位于下层的物理网络被称为 Underlay，负责基础物理网络的管理和互通（三层互通）；位于上层的虚拟逻辑网络被称为 Overlay，它用来实现满足上层需求的网络拓扑结构和通信处理。",-1))]),n[65]||(n[65]=s("p",null,[s("img",{src:"https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/250829-overlay-network-CAZ55HEj.png",alt:""})],-1)),n[66]||(n[66]=s("p",null,"软件定义网络的发展已经有 10 多年的历史了，期间发展出了众多硬件和软件层面的解决方案。由于以 Kubernetes 和 Docker 代表的容器间通信会使用到 Overlay 和 VXLAN 技术，因此这里只对 VXLAN 做简要介绍。",-1)),n[67]||(n[67]=s("p",null,[a("VXLAN（Virtual Extensible LAN）的前身是 VLAN（Virtual Local Area Network，虚拟局域网），其主要用来"),s("strong",null,"划分广播域"),a("，使得各个广播域实现逻辑隔离，只有域内的机器可以进行二层通信。广播域之间必须通过三层路由进行通信。")],-1)),s("p",null,[n[25]||(n[25]=s("img",{src:"https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/280829-vlan-communication-01.gif",alt:""},null,-1)),s("a",y,[n[24]||(n[24]=a("图片来源",-1)),t(e)])]),n[68]||(n[68]=s("p",null,"假设我们一个物理网络环境内有非常多的机器，机器二层通信时必须携带 MAC 头，一般都是通过 ARP 广播的形式获取目标 MAC 地址。但当环境内机器过多时，就会形成广播风暴，可能会引发严重的网络拥塞，但如果通过 VLAN 实现隔离，广播就只会在虚拟域内进行，从而减少影响。",-1)),n[69]||(n[69]=s("p",null,"VLAN 的设计存在两个问题：",-1)),n[70]||(n[70]=s("ol",null,[s("li",null,[s("p",null,[s("strong",null,"VLAN ID 的限制"),a("：传统 VLAN 使用12位的VLAN ID，最多支持 4096 个 VLAN，而在大规模数据中心环境中往往需要更多的隔离域。")])]),s("li",null,[s("p",null,[s("strong",null,"跨物理网络的限制"),a("：传统 VLAN 只能在同一物理网络内进行隔离，无法跨越不同的物理网络进行通信。")])])],-1)),s("p",null,[n[27]||(n[27]=a("为了解决上述问题，IETF 定义了 VXLAN 规范，虽然从名字上好像是 VLAN 的扩展协议，但和 VLAN 只能在二层工作不同，VXLAN 一开始就是为三层网络设计的，它是 ",-1)),s("a",x,[n[26]||(n[26]=a("Network Virtualization over Layer 3，NVO3，三层虚拟化网络",-1)),t(e)]),n[28]||(n[28]=a(" 规范之一，也是最主流的规范。",-1))]),n[71]||(n[71]=l(`<p>VXLAN 是典型的 Overlay 网络，通过 <strong>MAC in UDP</strong> 的报文形式封装数据，其大致流程如下：</p><ul><li>通信双方支持三层互联，两端都会创建 VETP（VXLAN Tunnel Endpoints，VXLAN 隧道端点）设备。</li><li>容器发送数据时，原始的二层 Frame 被发送至 VETH，添加 VXLAN Header 封装为 VXLAN 报文。</li><li>VXLAN 报文被主机封装为 UDP 包走正常的 IP 路由发送至目的主机。</li><li>UDP 包达到目的主机，携带的数据，即 VXLAN 报文被 VETP 设备处理。</li><li>VETP 设备解析出原始 Frame 发送至目标容器。</li></ul><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/250829-vxlan-001.png" alt=""></p><p>一个更详细的 VXLAN 报文格式如下：</p><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/250829-vxlan-002.jpg" alt=""></p><p>从左到右依次为：</p><ul><li><strong>Outer MAC Header</strong>：MAC 头信息，主要包含宿主机 MAC 地址以及下一站的目标 MAC 地址。</li><li><strong>Outer IP Header</strong>：IP 包信息，这里主要封装的是宿主机的 IP 和目的主机的 IP 地址。</li><li><strong>UDP Header</strong>：UDP 包，主要用于封装 VXLAN 报文，目标端口为 VXLAN Port，一般固定为 4789。</li><li><strong>VXLAN Header</strong>：VXLAN 信息，主要字段是占 24 位的 VNI（VXLAN Network Identifier）字段，用于标识 VXLAN 中的不同租户，24 位理论上的最大数量为 2^24 - 1 = 16777215，约为 1677 万。</li><li><strong>Origin Frame</strong>：原始帧，由容器发出的二层帧数据包。</li></ul><p>Linux 从 3.12 版本开始对 VXLAN 的支持达到完全完备的程度，其具有的高灵活性，可扩展和易于管理等特点：</p><ul><li>VXLAN 使用 24 位的 VXLAN 网络标识符（VNI），理论最多支持 1600 万虚拟网络。</li><li>完全可以在现有 IP 网络运行，无需对底层网络进行大规模改造。</li><li>只要数据中心间支持三层通信，就可以通过 VXLAN 建立隧道，实现跨数据中心的灵活通信。</li></ul><p>当然，任何方案都是一种 trade-off，VXLAN 在具有上述优势的同时，也会有一些不足：</p><ul><li><p><strong>传输效率不足</strong>：从上面的包结构分析中我们看到，报文新增了大约 50byte（Outer MAC Header 14 byte，Outer IP Header 20 byte， UDP Header 8 byte，VXLAN Header 8 byte），在传输大量数据时 50byte 的额外消耗不算什么，但对于小包传递会造成较大的额外开销。</p></li><li><p><strong>传输性能下降</strong>：这是所有需要封包解包的隧道技术的通病，和正常通信相比，传输流程多了 VXLAN 的封包与解包操作，会造成额外的资源消耗和性能损失。</p></li></ul><h2 id="kubernetes-网络通信" tabindex="-1"><a class="header-anchor" href="#kubernetes-网络通信" aria-hidden="true">#</a> Kubernetes 网络通信</h2><h3 id="container-to-container" tabindex="-1"><a class="header-anchor" href="#container-to-container" aria-hidden="true">#</a> Container To Container</h3><p>对于 Kubernetes，网络通信的面临四种情况：</p><ul><li>容器到容器（Container To Container）通信</li><li>Pod 到 Pod（Pod To Pod）通信</li><li>Pod 到 Service（Pod To Service）通信</li><li>外部到 Service（External To Service）通信</li></ul><p>熟悉了上述相关网络概念后，我们先对容器到容器（Container To Container）通信过程进行分析，后面会对其他场景进行讨论。</p><p>Docker 容器的网络有 4 种类型：</p><ul><li><p><strong>Bridge</strong> ：默认的网络模式，使用软件桥接的模式让链接到同一个Bridge上的容器进行通讯。</p></li><li><p><strong>Host</strong>：直接使用本机的网络资源，和普通的原生进程拥有同等的网络能力。</p></li><li><p><strong>MacVLAN</strong>：允许为容器分配mac地址，在有直接使用物理网络的需求下可以使用该网络类型。</p></li><li><p><strong>Overlay</strong>：在多个 Docker 宿主机之间创建一个分布式的网络，让属于不同的宿主机的容器也能进行通讯。</p></li></ul><p>Bridge, Host, MacVLAN 都是本机网络，Overlay 是跨宿主机的网络。当不允许 container 使用网络时，比如生成密钥哈希计算、有相关安全性需求的场景下，可以将网络类型设置成 None，即不允许该容器有网络通讯能力。</p><p>我们重点关注 Bridge 网桥模式，Docker 启动时会创建一个名为 docker0 的网桥，同主机上容器之间的通信都是通过该网桥实现的。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">ip</span> addr
<span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="token number">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet <span class="token number">127.0</span>.0.1/8 scope <span class="token function">host</span> lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope <span class="token function">host</span>
       valid_lft forever preferred_lft forever
<span class="token number">2</span>: eth0: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">1500</span> qdisc fq_codel state UP group default qlen <span class="token number">1000</span>
    link/ether 00:16:3e:16:3d:ab brd ff:ff:ff:ff:ff:ff
    altname enp0s5
    altname ens5
    inet <span class="token number">172.17</span>.150.182/20 metric <span class="token number">100</span> brd <span class="token number">172.17</span>.159.255 scope global dynamic eth0
       valid_lft 304340421sec preferred_lft 304340421sec
    inet6 fe80::216:3eff:fe16:3dab/64 scope <span class="token function">link</span>
       valid_lft forever preferred_lft forever
<span class="token number">3</span>: docker0: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">1500</span> qdisc noqueue state UP group default
    link/ether 02:42:7e:92:97:c9 brd ff:ff:ff:ff:ff:ff
    inet <span class="token number">172.18</span>.0.1/16 brd <span class="token number">172.18</span>.255.255 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:7eff:fe92:97c9/64 scope <span class="token function">link</span>
       valid_lft forever preferred_lft forever
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到有 docker0 设备，其 IP 地址为 <code>172.18.0.1/16</code>，这样之后创建的所有容器的 IP 地址都在 <code>172.18.0.0/16</code> 网段下，docker0 是该网段下的第一个地址。</p><p>当启动容器后，docker 会通过 Veth（Virtual Ethernet）对将容器和 docker0 网桥连起来，同时修改容器内的路由规则，当 container1 向 container2 发起请求时，基于路由规则会将请求路由到 docker0 网桥，然后在转发到 container2 中。我们使用如下命令创建两个 Nginx 容器，并查看其网络设备：</p><ul><li>创建容器</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>
$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> nginx1 <span class="token parameter variable">-p</span> <span class="token number">8080</span>:80 nginx
d0cdb3f0af4fb69c558638d1480dbbbe77239b283a235077a450a1e4fadb8ffc

$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> nginx2 <span class="token parameter variable">-p</span> <span class="token number">8081</span>:80 nginx
a4d7a79833a558a1dc619019b77938999557ef858ecc84b8c83844a22137fa56


$ <span class="token function">docker</span> <span class="token function">ps</span>
CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS                                   NAMES
a4d7a79833a5   nginx     <span class="token string">&quot;/docker-entrypoint.…&quot;</span>   <span class="token number">4</span> seconds ago    Up <span class="token number">2</span> seconds    <span class="token number">0.0</span>.0.0:8081-<span class="token operator">&gt;</span><span class="token number">80</span>/tcp, :::8081-<span class="token operator">&gt;</span><span class="token number">80</span>/tcp   nginx2
d0cdb3f0af4f   nginx     <span class="token string">&quot;/docker-entrypoint.…&quot;</span>   <span class="token number">13</span> seconds ago   Up <span class="token number">12</span> seconds   <span class="token number">0.0</span>.0.0:8080-<span class="token operator">&gt;</span><span class="token number">80</span>/tcp, :::8080-<span class="token operator">&gt;</span><span class="token number">80</span>/tcp   nginx1

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>查看网络设备</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">65536</span> qdisc noqueue state UNKNOWN mode DEFAULT group default qlen <span class="token number">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
<span class="token number">2</span>: eth0: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">1500</span> qdisc fq_codel state UP mode DEFAULT group default qlen <span class="token number">1000</span>
    link/ether 00:16:3e:16:3d:ab brd ff:ff:ff:ff:ff:ff
    altname enp0s5
    altname ens5
<span class="token number">3</span>: docker0: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">1500</span> qdisc noqueue state UP mode DEFAULT group default
    link/ether 02:42:7e:92:97:c9 brd ff:ff:ff:ff:ff:ff
<span class="token number">30</span>: vetha9d0324@if29: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">1500</span> qdisc noqueue master docker0 state UP mode DEFAULT group default
    link/ether ba:0f:72:b2:48:12 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="token number">0</span>
<span class="token number">32</span>: veth11ff0d5@if31: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">1500</span> qdisc noqueue master docker0 state UP mode DEFAULT group default
    link/ether 3a:2c:d0:46:01:24 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="token number">1</span>

$ <span class="token function">ip</span> <span class="token function">link</span> show master docker0
<span class="token number">30</span>: vetha9d0324@if29: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">1500</span> qdisc noqueue master docker0 state UP mode DEFAULT group default
    link/ether ba:0f:72:b2:48:12 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="token number">0</span>
<span class="token number">32</span>: veth11ff0d5@if31: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">1500</span> qdisc noqueue master docker0 state UP mode DEFAULT group default
    link/ether 3a:2c:d0:46:01:24 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到多了 <code>30: vetha9d0324@if29</code> 和 <code>32: veth11ff0d5@if31</code> 两个 veth 设备，并且都连到了 docker0 网桥。以第一个为例，其意思是编号为 30 的 veth 设备，与之配对的是 <code>@if29</code>，即编号为 29 的 veth，而这个设备应该是在容器内部的，我们进入对应容器查看一下。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--net</span> container:d0cdb3f0af4f nicolaka/netshoot
                    dP            dP                           dP
                    <span class="token number">88</span>            <span class="token number">88</span>                           <span class="token number">88</span>
88d888b. .d8888b. d8888P .d8888b. 88d888b. .d8888b. .d8888b. d8888P
<span class="token number">88</span><span class="token string">&#39;  \`88 88ooood8   88   Y8ooooo. 88&#39;</span>  <span class="token variable"><span class="token variable">\`</span><span class="token number">88</span> <span class="token number">88</span>&#39;  <span class="token variable">\`</span></span><span class="token number">88</span> <span class="token number">88</span><span class="token string">&#39;  \`88   88
88    88 88.  ...   88         88 88    88 88.  .88 88.  .88   88
dP    dP \`88888P&#39;</span>   dP   <span class="token variable"><span class="token variable">\`</span>88888P&#39; dP    dP <span class="token variable">\`</span></span>88888P<span class="token string">&#39; \`88888P&#39;</span>   dP

Welcome to Netshoot<span class="token operator">!</span> <span class="token punctuation">(</span>github.com/nicolaka/netshoot<span class="token punctuation">)</span>
Version: <span class="token number">0.13</span>


d0cdb3f0af4f  ~  <span class="token function">ip</span> addr
<span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="token number">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet <span class="token number">127.0</span>.0.1/8 scope <span class="token function">host</span> lo
       valid_lft forever preferred_lft forever
<span class="token number">29</span>: eth0@if30: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">1500</span> qdisc noqueue state UP group default
    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="token number">0</span>
    inet <span class="token number">172.18</span>.0.2/16 brd <span class="token number">172.18</span>.255.255 scope global eth0
       valid_lft forever preferred_lft forever

 d0cdb3f0af4f  ~  <span class="token function">cat</span> /sys/class/net/eth0/iflink
<span class="token number">30</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到容器内部的 eth0 设备为 <code>29: eth0@if30</code>，其编号为 29，关联的设备编号是 30。此时整个网络结构如图：</p><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/container-network.png" alt=""></p><p>知道了容器内网的网络情况，我们在看下数据是怎样传输的。首先看下容器内部的路由表信息</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>d0cdb3f0af4f  ~  route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         172.18.0.1      0.0.0.0         UG    0      0        0 eth0
172.18.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所有请求 <code>172.1.0.0/16</code> 网段的都会走 eth0 网卡，我们知道这个网卡是与 docker0 相连的，因此网络包会被发送给 docker0 网桥，最终由网桥进行地址转发，将网络包发送给对应的容器或者主机。</p><p>我们在来看下主机的路由表：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         172.17.159.253  0.0.0.0         UG    100    0        0 eth0
100.100.2.136   172.17.159.253  255.255.255.255 UGH   100    0        0 eth0
100.100.2.138   172.17.159.253  255.255.255.255 UGH   100    0        0 eth0
172.17.144.0    0.0.0.0         255.255.240.0   U     100    0        0 eth0
172.17.159.253  0.0.0.0         255.255.255.255 UH    100    0        0 eth0
172.18.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到请求 <code>172.18.0.0/16</code> 网段的都会路由至 docker0 设备，最终发送到某个容器，因此我们在主机访问刚创建的 NGINX 容器是可以访问成功的。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ curl 172.18.0.2
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
&lt;style&gt;
. . .
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>容器的网络 namespace 是互相隔离的，上述容器创建的过程基本可以概括为：</p><ul><li>创建 namespace</li><li>创建 veth 对并设置地址</li><li>将 veth 对一头连到容器的 namespace，一头连到docker0</li><li>启动 veth 设备，初始化路由表</li></ul><p>我们完全可以通过命令行模拟上述操作，实现两个网络 namespace 的互通，步骤如下：</p><p><strong>1. 创建 namespace</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">sudo</span> <span class="token function">ip</span> netns <span class="token function">add</span> test1
$ <span class="token function">sudo</span> <span class="token function">ip</span> netns <span class="token function">add</span> test2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2. 创建 veth 对</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">sudo</span> <span class="token function">ip</span> <span class="token function">link</span> <span class="token function">add</span> veth-test1 <span class="token builtin class-name">type</span> veth peer name veth-test2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>3. 将 veth 对加到 namespace 中</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">sudo</span> <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> veth-test1 netns test1
$ <span class="token function">sudo</span> <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> veth-test2 netns test2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>4. 给 veth 添加地址</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">sudo</span> <span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> test1 <span class="token function">ip</span> addr <span class="token function">add</span> <span class="token number">192.168</span>.1.1/24 dev veth-test1
$ <span class="token function">sudo</span> <span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> test2 <span class="token function">ip</span> addr <span class="token function">add</span> <span class="token number">192.168</span>.1.2/24 dev veth-test2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>5. 启动 veth 设备</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">sudo</span> <span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> test1 <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev veth-test1 up
$ <span class="token function">sudo</span> <span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> test2 <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev veth-test2 up
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>6. 在 test1 namespace 中访问 test2</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">sudo</span> <span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> test1 <span class="token function">ping</span> <span class="token number">192.168</span>.1.2
PING <span class="token number">192.168</span>.1.2 <span class="token punctuation">(</span><span class="token number">192.168</span>.1.2<span class="token punctuation">)</span> <span class="token number">56</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">)</span> bytes of data.
<span class="token number">64</span> bytes from <span class="token number">192.168</span>.1.2: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.060</span> ms
<span class="token number">64</span> bytes from <span class="token number">192.168</span>.1.2: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.053</span> ms
<span class="token number">64</span> bytes from <span class="token number">192.168</span>.1.2: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">3</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.038</span> ms
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="cni-规范" tabindex="-1"><a class="header-anchor" href="#cni-规范" aria-hidden="true">#</a> CNI 规范</h3><p>鉴于网络通信的复杂性与专业性，Kubernetes 本身并没有提供网络相关的功能。业界的做法是将网络功能从容器运行时以及容器编排工具中剥离出去，形成容器网络标准，具体实现以插件的形式接入，从而具有更好的扩展性，</p>`,55)),s("p",null,[n[30]||(n[30]=a("在早期 Docker 提出过 CNM 规范（Container Network Model，容器网络模型），但被后来 Kubernetes 提出的 ",-1)),s("a",S,[n[29]||(n[29]=a("CNI（Container Network Interface，容器网络接口）规范",-1)),t(e)]),n[31]||(n[31]=a(" 代替，两者功能基本一致。CNI 主要定义了两种能力：",-1))]),n[72]||(n[72]=s("ul",null,[s("li",null,[s("strong",null,"网络生命周期管理"),a("：主要负责网络的创建、删除等操作。")]),s("li",null,[s("strong",null,"IP 地址管理"),a("：主要包括 IP 地址的分配与回收，这里要求 Pod 的 IP 在集群内具有唯一性。")])],-1)),s("p",null,[n[33]||(n[33]=a("下面是 ",-1)),s("a",E,[n[32]||(n[32]=a("cni",-1)),t(e)]),n[34]||(n[34]=a(" 定义的接口，可以看到操作类只有 Add 和 Del 两种方法。",-1))]),n[73]||(n[73]=l(`<div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> CNI <span class="token keyword">interface</span> <span class="token punctuation">{</span>
	<span class="token function">AddNetworkList</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> net <span class="token operator">*</span>NetworkConfigList<span class="token punctuation">,</span> rt <span class="token operator">*</span>RuntimeConf<span class="token punctuation">)</span> <span class="token punctuation">(</span>types<span class="token punctuation">.</span>Result<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
	<span class="token function">CheckNetworkList</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> net <span class="token operator">*</span>NetworkConfigList<span class="token punctuation">,</span> rt <span class="token operator">*</span>RuntimeConf<span class="token punctuation">)</span> <span class="token builtin">error</span>
	<span class="token function">DelNetworkList</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> net <span class="token operator">*</span>NetworkConfigList<span class="token punctuation">,</span> rt <span class="token operator">*</span>RuntimeConf<span class="token punctuation">)</span> <span class="token builtin">error</span>
	<span class="token function">GetNetworkListCachedResult</span><span class="token punctuation">(</span>net <span class="token operator">*</span>NetworkConfigList<span class="token punctuation">,</span> rt <span class="token operator">*</span>RuntimeConf<span class="token punctuation">)</span> <span class="token punctuation">(</span>types<span class="token punctuation">.</span>Result<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
	<span class="token function">GetNetworkListCachedConfig</span><span class="token punctuation">(</span>net <span class="token operator">*</span>NetworkConfigList<span class="token punctuation">,</span> rt <span class="token operator">*</span>RuntimeConf<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token operator">*</span>RuntimeConf<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>

	<span class="token function">AddNetwork</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> net <span class="token operator">*</span>PluginConfig<span class="token punctuation">,</span> rt <span class="token operator">*</span>RuntimeConf<span class="token punctuation">)</span> <span class="token punctuation">(</span>types<span class="token punctuation">.</span>Result<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
	<span class="token function">CheckNetwork</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> net <span class="token operator">*</span>PluginConfig<span class="token punctuation">,</span> rt <span class="token operator">*</span>RuntimeConf<span class="token punctuation">)</span> <span class="token builtin">error</span>
	<span class="token function">DelNetwork</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> net <span class="token operator">*</span>PluginConfig<span class="token punctuation">,</span> rt <span class="token operator">*</span>RuntimeConf<span class="token punctuation">)</span> <span class="token builtin">error</span>
	<span class="token function">GetNetworkCachedResult</span><span class="token punctuation">(</span>net <span class="token operator">*</span>PluginConfig<span class="token punctuation">,</span> rt <span class="token operator">*</span>RuntimeConf<span class="token punctuation">)</span> <span class="token punctuation">(</span>types<span class="token punctuation">.</span>Result<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
	<span class="token function">GetNetworkCachedConfig</span><span class="token punctuation">(</span>net <span class="token operator">*</span>PluginConfig<span class="token punctuation">,</span> rt <span class="token operator">*</span>RuntimeConf<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token operator">*</span>RuntimeConf<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>

	<span class="token function">ValidateNetworkList</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> net <span class="token operator">*</span>NetworkConfigList<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
	<span class="token function">ValidateNetwork</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> net <span class="token operator">*</span>PluginConfig<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>

	<span class="token function">GCNetworkList</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> net <span class="token operator">*</span>NetworkConfigList<span class="token punctuation">,</span> args <span class="token operator">*</span>GCArgs<span class="token punctuation">)</span> <span class="token builtin">error</span>
	<span class="token function">GetStatusNetworkList</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> net <span class="token operator">*</span>NetworkConfigList<span class="token punctuation">)</span> <span class="token builtin">error</span>

	<span class="token function">GetCachedAttachments</span><span class="token punctuation">(</span>containerID <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>NetworkAttachment<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>

	<span class="token function">GetVersionInfo</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> pluginType <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>version<span class="token punctuation">.</span>PluginInfo<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有了 CNI 规范，针对容器的网络操作就只需要面向 CNI 即可，在创建 Pod 时，由由容器运行时访问 CNI 接口，最终由网络插件完成 Pod 网络环境的设置，而 Kubernetes 不关心具体的实现细节。大致工作流程如下：</p><ol><li>所有可用的插件全部位于 <code>/opt/cni/bin</code> 目录。</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ ls /opt/cni/bin/
bandwidth  calico       dhcp   firewall  host-device  ipvlan    macvlan  ptp  static  tuning  vrf
bridge     calico-ipam  dummy  flannel   host-local   loopback  portmap  sbr  tap     vlan
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>被选定的 CNI 插件会在 <code>/etc/cni/net.d/</code> 目录下创建配置文件，以 flannel 为例配置如下：</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>{
  &quot;cniVersion&quot;: &quot;0.3.1&quot;,
  &quot;name&quot;: &quot;container-cni-list&quot;,
  &quot;plugins&quot;: [
    {
      &quot;type&quot;: &quot;flannel&quot;,
      &quot;delegate&quot;: {
        &quot;isDefaultGateway&quot;: true,
        &quot;hairpinMode&quot;: true,
        &quot;ipMasq&quot;: true,
        &quot;kubeconfig&quot;: &quot;/etc/cni/net.d/flannel-kubeconfig&quot;
      }
    }
  ]
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li><p>容器运行时基于上述配置将列表的第一个插件选择为默认插件。</p></li><li><p>kubelet 给予 CRI 接口调用容器运行时创建 Pod。</p></li><li><p>容器运行时负责创建网络 namespace，并调用 CNI 为 Pod 分配网络。</p></li><li><p>CNI 配置完成后将 IP 地址等信息返回给容器运行时，在由 kubelet 更新到 Pod 的状态字段中，完成网络配置。</p></li></ol><p>通过 CNI 这种开放性设计，Kubernetes 不需要在关心复杂的网络实现，转而交给社区去实现，从而打造出了丰富的 Kubernetes 网络插件形态。下面是一些常见的 CNI 插件：</p><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/k8s-network-02.png" alt="在这里插入图片描述"></p><h3 id="跨主机的网络通信" tabindex="-1"><a class="header-anchor" href="#跨主机的网络通信" aria-hidden="true">#</a> 跨主机的网络通信</h3><p>Docker 是单机的，而 Kubernetes 通常是多节点的集群，因此不同节点的 Pod 需要进行跨主机的网络通信。跨主机的网络通信方案目前主要有三种方式：</p><p><strong>Overlay 模式</strong></p><p>在基础物理网络之上，在虚拟化一层网络来进行网络通信。像 Flannel 的 VXLAN 、Calico 的 IPIP 模式、Weave 等 CNI 插件都采用的了该模式。</p><p><strong>路由模式</strong></p><p>该模式下跨主机的网络通信是直接通过宿主机的路由转发实现的，和 Overlay 相比其优势在于无需额外的封包解包，性能会有所提升，但坏处是路由转发依赖网络底层环境的支持，要么支持二层连通，要么支持 BGP 协议实现三层互通。Flannel 的 HostGateway 模式、Calico 的 BGP 模式都是该模式的代表。</p><p><strong>Underlay 模式</strong></p><p>容器直接使用宿主机网络通信，直接依赖于虚拟化设备和底层网络设施，上面的路由模式也算是 Underlay 模式的一种。理论上该模式是性能最好的，但因为必须依赖底层，并且可能需要特定的软硬件部署，无法做到 Overlay 那样的自由灵活的使用。</p><h3 id="pod-to-pod" tabindex="-1"><a class="header-anchor" href="#pod-to-pod" aria-hidden="true">#</a> Pod To Pod</h3><p>下面以 Flannel 插件的实现为例看下最常见的 Overlay 和路由模式的具体实现。</p><p><strong>注意：Flannel 插件的更新已经停止，实际生产中已经不再建议使用。这里只是为了方便理解选择了相对直观的 Flannel 插件做学习。</strong></p><h4 id="flannel-udp" tabindex="-1"><a class="header-anchor" href="#flannel-udp" aria-hidden="true">#</a> Flannel UDP</h4><p>Flannel 是 CoreOS 为 Kubernetes 设计的配置三层网络（IP层）的开源解决方案。其构建 Overlay 网络有两种模式：UDP 和 VXLAN。我们首先看下 UDP 模式。</p><p>Flannel 会创建名为 kube-flannel 的 DaemonSet 对象，从而在每个节点上创建 Pod 运行 flanneld 程序。另外 Flannel 还会创建名为 flannel.0 的虚拟网络设备，在主机网络上创建另外一层扁平的 Overlay 网络。</p><p>在 Overlay 网络中，每个 Pod 都有唯一的 IP，Pod 之间可以直接使用 IP 地址和其他节点的 Pod 通信。另外 Kubernetes 会在每个节点上创建一个 cni0 bridge 来实现本机容器的通讯，通信过程和我们上面提到的容器间的网络通信基本一致，这里我们只关注跨节点的网络通信。</p><p>首先看一下集群内节点和 Pod 的 IP 地址：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ kubectl get nodes <span class="token parameter variable">-o</span> wide
NAME    STATUS   ROLES           AGE   VERSION   INTERNAL-IP   EXTERNAL-IP   OS-IMAGE           KERNEL-VERSION       CONTAINER-RUNTIME
node1   Ready    control-plane   24h   v1.30.4   <span class="token number">172.19</span>.0.8    <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>        Ubuntu <span class="token number">22.04</span> LTS   <span class="token number">5.15</span>.0-124-generic   containerd://1.7.23
node2   Ready    control-plane   24h   v1.30.4   <span class="token number">172.19</span>.0.13   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>        Ubuntu <span class="token number">22.04</span> LTS   <span class="token number">5.15</span>.0-124-generic   containerd://1.7.23
node3   Ready    <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>          24h   v1.30.4   <span class="token number">172.19</span>.0.15   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>        Ubuntu <span class="token number">22.04</span> LTS   <span class="token number">5.15</span>.0-124-generic   containerd://1.7.23

$ kubectl get pods <span class="token parameter variable">-o</span> wide
NAME                               READY   STATUS    RESTARTS   AGE   IP            NODE    NOMINATED NODE   READINESS GATES
nginx-deployment-576c6b7b6-6rdhf   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          24h   <span class="token number">10.233</span>.66.2   node3   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>           <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>
nginx-deployment-576c6b7b6-jdt7x   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          24h   <span class="token number">10.233</span>.64.4   node1   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>           <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>
nginx-deployment-576c6b7b6-rrgtc   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          24h   <span class="token number">10.233</span>.65.3   node2   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>           <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看三个节点的 IP 信息，可以看到每个节点都有 flannel.0 设备，IP 依次是 10.233.64.0/32、10.233.65.0/32、10.233.66.0/32。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ node1
11: flannel0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 8450 qdisc noqueue state UNKNOWN group default
    link/ether 02:df:3d:63:5f:1c brd ff:ff:ff:ff:ff:ff
    inet 10.233.64.0/32 scope global flannel0

$ node2
11: flannel.0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 8450 qdisc noqueue state UNKNOWN group default
    link/ether 02:df:3d:63:5f:1c brd ff:ff:ff:ff:ff:ff
    inet 10.233.65.0/32 scope global flannel.0

$ node3
11: flannel.0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 8450 qdisc noqueue state UNKNOWN group default
    link/ether 02:df:3d:63:5f:1c brd ff:ff:ff:ff:ff:ff
    inet 10.233.66.0/32 scope global flannel.0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们在查看下 node1 节点上的路由表：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ ip route
default via 172.19.0.1 dev eth0 proto dhcp src 172.19.0.8 metric 100
10.233.64.0/24 dev cni0 proto kernel scope link src 10.233.64.1
10.233.65.0/24 via 10.233.65.0 dev flannel.0 onlink
10.233.66.0/24 via 10.233.66.0 dev flannel.0 onlink
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到如果是发送给 10.233.64.0/24 即 node1 的 Pod 的 IP 地址，则直接通过 cni0 设备发送，如果是 10.233.65.0/24 和 10.233.66.0/24 也就是访问 node2、node3 的 Pod ，则通过 flannel.0 设备发送，下面是整体通信流程：</p><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/250829-flannel-upd-01.png" alt=""></p><ul><li>创建原始 IP 包，源地址为 node1 中 Pod IP，目的地址为 node2 中 Pod IP。</li><li>数据包通过 veth 设备从 node1 的 Pod 发送到 cni0 bridge。</li><li>cni0 bridge 将数据包发送到 flannel.0 设备（根据主机路由表判断）。</li><li>发给 flannel.0 的包会由 flanneld 程序处理，它会将 IP 包作为数据打包到 UDP 包中，并在 etcd 中找到目标 Pod 所在节点的 IP 地址（即 Node2 的 IP 地址），最终封装为完整的 IP 包进行发送。</li><li>Node2 收到 IP 包后进行逆向操作，先将数据报发送给 flanneld 程序，解包后经 flannel.1、cni0 bridge 最终发送到容器。</li></ul><p>在 UDP 模式下，flanneld 程序需要将数据包打包到 UDP 包中，然后发送给目标节点，目标节点再进行解包，可以看到每次打包都需要 3 次内核态和用户态的转换，因此 UDP 模式下性能较低，已经不再推荐使用。</p><h4 id="flannel-vxlan" tabindex="-1"><a class="header-anchor" href="#flannel-vxlan" aria-hidden="true">#</a> Flannel VXLAN</h4><p>Flannel 默认采用 VXLAN 模式，通过 VXLAN 在主机之间建立逻辑隧道，并且直接在内核打包，从而提升性能。在 VXLAN 模式下，每个节点都会创建一个 VTEP 设备，可以通过 <code>ip link show type vxlan</code> 查看。执行命令后可以看到，我们的三个节点每个节点都有 flannel.1 的 vxlan 设备，端口为 8472，VNI 为 1。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ node1 &gt; ip -d addr show type vxlan
11: flannel.1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 8450 qdisc noqueue state UNKNOWN group default
    link/ether 02:df:3d:63:5f:1c brd ff:ff:ff:ff:ff:ff promiscuity 0 minmtu 68 maxmtu 65535
    vxlan id 1 local 172.19.0.8 dev eth0 srcport 0 0 dstport 8472 nolearning ttl auto ageing 300 udpcsum noudp6zerocsumtx noudp6zerocsumrx numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535
    inet 10.233.64.0/32 scope global flannel.1


$ node2 &gt; ip -d addr show type vxlan
10: flannel.1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 8450 qdisc noqueue state UNKNOWN group default
    link/ether aa:4d:1c:d6:b1:4a brd ff:ff:ff:ff:ff:ff promiscuity 0 minmtu 68 maxmtu 65535
    vxlan id 1 local 172.19.0.13 dev eth0 srcport 0 0 dstport 8472 nolearning ttl auto ageing 300 udpcsum noudp6zerocsumtx noudp6zerocsumrx numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535
    inet 10.233.65.0/32 scope global flannel.1


$ node3 &gt; ip -d addr show type vxlan
10: flannel.1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 8450 qdisc noqueue state UNKNOWN group default
    link/ether 3a:71:37:9f:0f:b9 brd ff:ff:ff:ff:ff:ff promiscuity 0 minmtu 68 maxmtu 65535
    vxlan id 1 local 172.19.0.15 dev eth0 srcport 0 0 dstport 8472 nolearning ttl auto ageing 300 udpcsum noudp6zerocsumtx noudp6zerocsumrx numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535
    inet 10.233.66.0/32 scope global flannel.1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Flannel 在 VXLAN 模式下的数据传输过程如下：</p><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/flannel-vxlan.png" alt="flannel-vxlan"></p><ol><li>Pod 发送请求，IP 包的源地址和目的地址是源 Pod IP 和目的 Pod IP。</li><li>数据报经由 cni0 bridge 传输到 flannel.1 设备进行 VXLAN 封包，然后作为 UDP 包发出。</li><li>node1 将 UDP 包发送到 node2</li><li>node2 收到 UDP 包后，flannel.1 设备接收进行解包，获取内部的数据包。</li><li>数据包发送到 cni0 bridge 设备，然后转发到目标 Pod。</li></ol><p>我们用 tcpdump 抓包后用 wireshark 打开看下 UDP 包中 VXLAN 的信息如下：</p><ul><li>外层包目的地址是 node2 的 IP 地址：172.19.0.13。</li><li>外层包目的端口为 8472，对应 flannel.1 的端口</li><li>VNI 为 1，表示 flannel.1 对应的 VNI</li><li>VXLAN 内部封装的 IP 包源地址和目的地址就是源 Pod 和目标 Pod 的 IP 地址。</li></ul><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/flannel-vxlan-wireshark.png" alt=""></p><h4 id="flannel-host-gw" tabindex="-1"><a class="header-anchor" href="#flannel-host-gw" aria-hidden="true">#</a> Flannel host-gw</h4><p>Flannel 的 host-gw 模式是基于路由的网络方案，和 VXLAN 模式不同，host-gw 模式下，Flannel 会直接将数据包发送给目标节点，无需经过中间的 VXLAN 隧道。可以通过修改其配置设置为 <code>host-gw</code> 来设置。</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">net-conf.json</span><span class="token punctuation">:</span>
<span class="token punctuation">---</span><span class="token punctuation">-</span>
<span class="token punctuation">{</span>
  <span class="token key atrule">&quot;Network&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;10.233.64.0/18&quot;</span><span class="token punctuation">,</span>
  <span class="token key atrule">&quot;EnableIPv4&quot;</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token punctuation">,</span>
  <span class="token key atrule">&quot;Backend&quot;</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token key atrule">&quot;Type&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;host-gw&quot;</span>      
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 host-gw 模式下，当 Pod 创建并分配 IP 时，Flannel 会在主机创建路由规则，Pod 之间的通信是通过 IP 路由实现的。我们在创建一个三实例的 Nginx Deployment 并查看主机的路由规则。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">ip</span> <span class="token function">link</span> show <span class="token builtin class-name">type</span> vxlan


$ <span class="token function">ip</span> <span class="token parameter variable">-d</span> addr
<span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="token number">1000</span>
    inet <span class="token number">127.0</span>.0.1/8 scope <span class="token function">host</span> lo

<span class="token number">2</span>: eth0: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">8500</span> qdisc mq state UP group default qlen <span class="token number">1000</span>
    inet <span class="token number">172.19</span>.0.8/20 metric <span class="token number">100</span> brd <span class="token number">172.19</span>.15.255 scope global eth0


<span class="token number">23</span>: cni0: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">8500</span> qdisc noqueue state UP group default qlen <span class="token number">1000</span>

    inet <span class="token number">10.233</span>.64.1/24 brd <span class="token number">10.233</span>.64.255 scope global cni0
       valid_lft forever preferred_lft forever

<span class="token number">24</span>: veth36c11991@if2: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">8500</span> qdisc noqueue master cni0 state UP group default

<span class="token number">25</span>: vethf7cb8841@if2: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">8500</span> qdisc noqueue master cni0 state UP group default

<span class="token number">26</span>: nodelocaldns: <span class="token operator">&lt;</span>BROADCAST,NOARP<span class="token operator">&gt;</span> mtu <span class="token number">1500</span> qdisc noop state DOWN group default
  
<span class="token number">27</span>: vethadfffbd3@if2: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">8500</span> qdisc noqueue master cni0 state UP group default
  

$ <span class="token function">ip</span> <span class="token parameter variable">-d</span> route
unicast default via <span class="token number">172.19</span>.0.1 dev eth0 proto dhcp scope global src <span class="token number">172.19</span>.0.8 metric <span class="token number">100</span>
unicast <span class="token number">10.233</span>.64.0/24 dev cni0 proto kernel scope <span class="token function">link</span> src <span class="token number">10.233</span>.64.1
unicast <span class="token number">10.233</span>.65.0/24 via <span class="token number">172.19</span>.0.13 dev eth0 proto boot scope global
unicast <span class="token number">10.233</span>.66.0/24 via <span class="token number">172.19</span>.0.15 dev eth0 proto boot scope global
unicast <span class="token number">172.19</span>.0.0/20 dev eth0 proto kernel scope <span class="token function">link</span> src <span class="token number">172.19</span>.0.8 metric <span class="token number">100</span>
unicast <span class="token number">172.19</span>.0.1 dev eth0 proto dhcp scope <span class="token function">link</span> src <span class="token number">172.19</span>.0.8 metric <span class="token number">100</span>
unicast <span class="token number">183.60</span>.82.98 via <span class="token number">172.19</span>.0.1 dev eth0 proto dhcp scope global src <span class="token number">172.19</span>.0.8 metric <span class="token number">100</span>
unicast <span class="token number">183.60</span>.83.19 via <span class="token number">172.19</span>.0.1 dev eth0 proto dhcp scope global src <span class="token number">172.19</span>.0.8 metric <span class="token number">100</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到主机上没有创建 vxlan 设备，而是建好了 3 条路由规则：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">ip</span> <span class="token parameter variable">-d</span> route
unicast <span class="token number">10.233</span>.64.0/24 via <span class="token number">172.19</span>.0.8 dev eth0 proto boot scope global
unicast <span class="token number">10.233</span>.65.0/24 dev cni0 proto kernel scope <span class="token function">link</span> src <span class="token number">10.233</span>.65.1
unicast <span class="token number">10.233</span>.66.0/24 via <span class="token number">172.19</span>.0.15 dev eth0 proto boot scope global

$ kubectl get nodes <span class="token parameter variable">-o</span> wide
NAME    STATUS   ROLES           AGE   VERSION   INTERNAL-IP   EXTERNAL-IP   OS-IMAGE           KERNEL-VERSION       CONTAINER-RUNTIME
node1   Ready    control-plane   12m   v1.30.4   <span class="token number">172.19</span>.0.8    <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>        Ubuntu <span class="token number">22.04</span> LTS   <span class="token number">5.15</span>.0-124-generic   containerd://1.7.23
node2   Ready    control-plane   12m   v1.30.4   <span class="token number">172.19</span>.0.13   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>        Ubuntu <span class="token number">22.04</span> LTS   <span class="token number">5.15</span>.0-124-generic   containerd://1.7.23
node3   Ready    <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>          11m   v1.30.4   <span class="token number">172.19</span>.0.15   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>        Ubuntu <span class="token number">22.04</span> LTS   <span class="token number">5.15</span>.0-124-generic   containerd://1.7.23


$ kubectl get pods <span class="token parameter variable">-o</span> wide
NAME                               READY   STATUS    RESTARTS   AGE    IP            NODE    NOMINATED NODE   READINESS GATES
nginx-deployment-576c6b7b6-8snps   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          104s   <span class="token number">10.233</span>.65.3   node2   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>           <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>
nginx-deployment-576c6b7b6-8t282   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          104s   <span class="token number">10.233</span>.66.2   node3   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>           <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>
nginx-deployment-576c6b7b6-ttn9g   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          104s   <span class="token number">10.233</span>.64.4   node1   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>           <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们以 node02 节点看到的 <code>unicast 10.233.64.0/24 via 172.19.0.8 dev eth0 proto boot scope global</code> 这条规则为例，其含义是<strong>对 10.233.64.0/24 网段的数据包，通过 eth0 网卡，发往 172.19.0.8 这个 IP 地址</strong>。</p><p>因此如果我们访问位于 Node01 的 nginx-deployment-576c6b7b6-ttn9g（IP：10.233.64.4），那么数据包会通过 eth0 网卡，发往 172.19.0.8 这个 IP 地址，然后通过 172.19.0.8 这个 IP 地址，发往 10.233.64.4 这个 IP 地址。</p><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/flannel-hostgw.png" alt="host-gw"></p><p>host-gw 有几个特点：</p><ul><li><p>省去了 overlay 网络的封包解包过程，性能上会有所提升。host-gw 的性能损失大约在 10% 左右，而其他所有基于 VXLAN 隧道机制的网络方案，性能损失在 20%~30% 左右。</p></li><li><p>通过路由规则可以看到，当在 node02 访问 node01 的 Pod 时，数据包是直接路由到了 node01，node02 需要通过 ARP 协议获取 node01 的 Mac 地址后发送数据包，因此 node02 需要和 node01 二层互通。也就是说 host-gw 模式下，K8s 集群节点必须都是二层互通的。</p></li></ul><h4 id="calico-bgp-模式" tabindex="-1"><a class="header-anchor" href="#calico-bgp-模式" aria-hidden="true">#</a> Calico BGP 模式</h4><h3 id="service-to-pod" tabindex="-1"><a class="header-anchor" href="#service-to-pod" aria-hidden="true">#</a> Service To Pod</h3><h4 id="service-简介" tabindex="-1"><a class="header-anchor" href="#service-简介" aria-hidden="true">#</a> Service 简介</h4><p>Kuberetes 通过抽象的 Service 来组织对集群内 pod 的访问，因为 pod 是可以被动态创建和销毁的，其 IP 地址也会随之变化，所以需要一个抽象的资源来做稳定的服务发现和负载均衡，Service 就是这样一个资源对象。Service 通过 <code>Label Selector</code> 来选定一组 Pod，然后为这组 Pod 提供一个稳定的访问入口。</p><p>我们使用如下 yaml 文件创建一个有 3 个副本的 nginx deployment 并创建 Service。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: <span class="token number">3</span>  <span class="token comment"># 创建 3 个 Pod</span>
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:latest  <span class="token comment"># 使用最新的 NGINX 镜像</span>
        ports:
        - containerPort: <span class="token number">80</span>
---
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
  labels:
    app: nginx
spec:
  type: ClusterIP  <span class="token comment"># 服务类型为 ClusterIP</span>
  selector:
    app: nginx
  ports:
  - protocol: TCP
    port: <span class="token number">80</span>          <span class="token comment"># Service 的端口</span>
    targetPort: <span class="token number">80</span>    <span class="token comment"># Pod 内容器的端口</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然 Service 是对 Pod 的代理和负载均衡，但 Service 和 Pod 并不直接发生关联，而是通过 Endpoints 对象关联。处于 Running 状态，并且通过 readinessProbe 检查的 Pod 会出现在 Service 的 Endpoints 列表里，当某一个 Pod 出现问题时，Kubernetes 会自动把它从 Endpoints 列表里摘除掉。</p><p>在早期版本中， Service 只会包含一个 Endpoints 对象，当 Pod 的 IP 发生变化时，Endpoints 对象的 IP 也会随之变化，但这样可能会导致 Endpoints 对象的 IP 列表频繁变化，比如某个 Pod 有 3000 个副本需要滚动升级，这样会导致 Endpoints 至少变动 3000 次，同时也会导致 iptables 规则频繁更新，从而导致性能问题。</p><p>为了解决这个问题，Kubernetes 在 1.14 版本引入了 EndpointSlice 并在 1.19 版本默认启用，其思路非常简单：将一个 Endpoints 对象分成多个 EndpointSlice 对象。每次变更只更新部分 EndpointSlice 对象，从而减少 Endpoints 对象的变动。</p><p><img src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*6qbSvRldvpgPIExIq8fiGw.png" alt="EndpointSlice"></p>`,65)),s("p",null,[n[36]||(n[36]=a("图片来自：",-1)),s("a",N,[n[35]||(n[35]=a("A Hands-On Guide to Kubernetes Endpoints & EndpointSlices",-1)),t(e)])]),n[74]||(n[74]=l(`<p>下面是使用上述 yaml 创建的 nginx 的 Pod、Service、Endpoints 对象，可以看到有一个和 Service 同名的 Endpoints 对象，包含了3 个 Pod 的 IP。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ kubectl get svc
NAME            TYPE        CLUSTER-IP      EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>   AGE
kubernetes      ClusterIP   <span class="token number">10.233</span>.0.1      <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>        <span class="token number">443</span>/TCP   44h
nginx-service   ClusterIP   <span class="token number">10.233</span>.32.140   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>        <span class="token number">80</span>/TCP    24h

$ kubectl get endpoints
NAME            ENDPOINTS                                         AGE
nginx-service   <span class="token number">10.233</span>.102.131:80,10.233.71.2:80,10.233.75.2:80   24h


$ kubectl get endpointslices
NAME                   ADDRESSTYPE   PORTS   ENDPOINTS                                AGE
nginx-service-zsrzj    IPv4          <span class="token number">80</span>      <span class="token number">10.233</span>.102.131,10.233.75.2,10.233.71.2   25h

$ kubectl get pods  <span class="token parameter variable">-o</span> wide
NAME                                READY   STATUS    RESTARTS   AGE   IP               NODE    NOMINATED NODE   READINESS GATES
nginx-deployment-54b9c68f67-cfpgf   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          24h   <span class="token number">10.233</span>.75.2      node2   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>           <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>
nginx-deployment-54b9c68f67-kldjf   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          24h   <span class="token number">10.233</span>.71.2      node3   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>           <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>
nginx-deployment-54b9c68f67-q4ggs   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          24h   <span class="token number">10.233</span>.102.131   node1   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>           <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Service 是通过 <code>Label Selector</code> 来选定要代理的 Pod 的，但其可以分为有 <code>Label Selector</code> 和没有 <code>Label Selector</code> 的Service， 两者的差别在于：</p><ul><li><p>有 <code>Label Selector</code> 的 Service 用来代理一组 Pod，主要是为集群内 Pod 提供服务发现、负载均衡。</p></li><li><p>没有 <code>Label Selector</code> 的 Service 通常用来代理集群外部的服务，主要应用于如下的场景:</p><ul><li>访问的 Service 在生产中是一个集群外服务，比如云数据库。服务不在集群内但是需要通过集群内部访问。</li><li>所访问的服务不在同一个命名空间。</li><li>正在迁移服务到 Kubernetes，并只有部分backend服务移到K8s中。</li></ul></li></ul><p>因为 Service 是基于通过 Endpoints 进行代理，所以 Endpoints 内的 IP 地址并不一定都是 Pod 的 IP，完全可以是 K8s 集群外的服务。比如我们的 ElasticSearch 集群是部署在主机上的，可以通过下面的方式创建 Service，这样在应用内部就可以配置固定域名来对 ElasticSearch 进行访问，如果 ElasticSearch 服务的 IP 发生变化，只需要修改 EndPoints 即可无需修改应用配置。</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> elasticsearch
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">ports</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9200</span>
    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP
    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">9200</span>

<span class="token punctuation">---</span>

<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Endpoints
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> elasticsearch
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default
<span class="token key atrule">subsets</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">addresses</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">ip</span><span class="token punctuation">:</span> 192.168.24.14
  <span class="token punctuation">-</span> <span class="token key atrule">ip</span><span class="token punctuation">:</span> 192.168.24.15
  <span class="token punctuation">-</span> <span class="token key atrule">ip</span><span class="token punctuation">:</span> 192.168.24.16
  <span class="token key atrule">ports</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9200</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="service-分类" tabindex="-1"><a class="header-anchor" href="#service-分类" aria-hidden="true">#</a> Service 分类</h4><p>Service 主要有下面 5 种类型（ServiceType）：</p><h5 id="_5-2-1-clusterip" tabindex="-1"><a class="header-anchor" href="#_5-2-1-clusterip" aria-hidden="true">#</a> 5.2.1 ClusterIP</h5><p>这是 Service 的默认模式，使用集群内部 IP 进行 Pod 的访问，对集群外不可见。ClusterIP 其实是一条 iptables 规则，不是一个真实的 IP，不能被路由到。kubernetes通过 iptables 把对 ClusterIP:Port 的访问重定向到 kube-proxy 或者具体的 pod 上。</p><h5 id="_5-2-2-nodeport" tabindex="-1"><a class="header-anchor" href="#_5-2-2-nodeport" aria-hidden="true">#</a> 5.2.2 NodePort</h5><p>NodePort 与 Cluster IP不一样的是，它会集群中的每个节点开一个稳定的端口（范围 30000 - 32767 ）给外部访问。</p><p>当 Service 以 NodePort 的方式 expose 的时候，此时该服务会有三个端口：port，targetPort，nodePort。</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>world
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">type</span><span class="token punctuation">:</span> NodePort
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>world
  <span class="token key atrule">ports</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP
      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span>
      <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80</span>
      <span class="token key atrule">nodePort</span><span class="token punctuation">:</span> <span class="token number">30036</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>nodePort: 30036 是搭配 NodeIP 提供给集群外部访问的端口。</li><li>port:8080 是集群内访问该服务的端口。</li><li>targetPort:80 是Pod 内容器服务监听的端口。</li></ul><h5 id="_5-2-3-loadbalancer" tabindex="-1"><a class="header-anchor" href="#_5-2-3-loadbalancer" aria-hidden="true">#</a> 5.2.3 LoadBalancer</h5><p>负载均衡器，一般都是在使用云厂商提供的 Kubernetes 服务时，使用各种云厂商提供的负载均衡能力，使我们的服务能在集群外被访问。</p>`,17)),s("p",null,[n[38]||(n[38]=a("如果是自己部署的集群，Kubernetes 本身没有提供类似功能，可以使用 ",-1)),s("a",T,[n[37]||(n[37]=a("MetalLB",-1)),t(e)]),n[39]||(n[39]=a(" 来部署。",-1))]),n[75]||(n[75]=l(`<h5 id="_5-2-4-externalname-service" tabindex="-1"><a class="header-anchor" href="#_5-2-4-externalname-service" aria-hidden="true">#</a> 5.2.4 ExternalName Service</h5><p>ExternalName Service 用来映射集群外服务的 DNS，意思是这个服务不在 Kubernetes 里，但是可以由 Kubernetes 的 Service 进行转发。</p><p>比如：我们有一个AWS RDS 的服务，其地址是 <code>test.database.aws-cn-northeast1b.com</code>，但为了屏蔽细节以及为了方便日后的迁移，但我们应用内配置的 URL 是 <code>db-service</code>。这时就可以创建一个名为 <code>db-service</code> 的 ExternalName Service 将其映射到外部的 DNS 地址。集群内的 pod 访问 db-service 时，Kubernetes DNS 服务器将返回带有 CNAME 记录的 test.database.aws-cn-norheast1b.com。</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> db<span class="token punctuation">-</span>service
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">type</span><span class="token punctuation">:</span> ExternalName
  <span class="token key atrule">externalName</span><span class="token punctuation">:</span> test.database.aws<span class="token punctuation">-</span>cn<span class="token punctuation">-</span>northeast1b.com
  <span class="token key atrule">ports</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_5-2-5-headless-service" tabindex="-1"><a class="header-anchor" href="#_5-2-5-headless-service" aria-hidden="true">#</a> 5.2.5 Headless Service</h5><p>有时候如果我们不需要 Service 作为负载均衡转发请求，我们可以把 ClusterIP 设置成 None，从而创建一个 HeadlessService。示例如下：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>headless
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">clusterIP</span><span class="token punctuation">:</span> None
  <span class="token key atrule">ports</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是相关信息</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ kubectl get svc
NAME             TYPE        CLUSTER-IP      EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>   AGE
nginx-headless   ClusterIP   None            <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>        <span class="token number">80</span>/TCP    3s


<span class="token comment"># ubuntu @ node1 in ~/kubespec [13:54:58]</span>
$ kubectl get endpoints
NAME             ENDPOINTS                                         AGE
nginx-headless   <span class="token number">10.233</span>.102.131:80,10.233.71.2:80,10.233.75.2:80   13s
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到 Headless Service 自身没有 IP 地址，当 Pod 通过该服务访问时，不会走 kube-proxy 将请求转发到某个 Pod 或外部节点，而是其会返会 Endpoints 列表里的 IP 地址，Pod 拿到 IP 自行决定去访问哪些地址。 在部署有状态应用经常会用到 HeadlessService 以减少节点之间的通信时间。</p><p>这里我们只是简单介绍 Service 的相关定义，更多的使用还请参考官方文档，我们重点来看下 Service 的请求转发是如何实现的。</p><h4 id="kube-proxy-实现原理" tabindex="-1"><a class="header-anchor" href="#kube-proxy-实现原理" aria-hidden="true">#</a> kube-proxy 实现原理</h4><p>Service 相关的请求转发是由 kube-proxy 组件实现的，每个节点上都会运行该组件。kube-proxy 会监听集群中 Service 和 Endpoints 的变化，并基于此更新每台节点的 iptables 或 ipvs 等规则，从而完成请求的转发。鉴于篇幅原因，我们这里只对最常用的 ClusterIP 类型的 Service 做介绍。</p><p>kube-proxy 的代理模式有下面几种：</p><ul><li>UserSpace 模式（已废弃）</li><li>iptables 模式（默认）</li><li>ipvs 模式</li><li>nftables 模式（实验性）</li></ul><p>我们来分别看下这几种模式的工作原理。</p><h5 id="userspace-模式" tabindex="-1"><a class="header-anchor" href="#userspace-模式" aria-hidden="true">#</a> UserSpace 模式</h5><p>这是早期使用的一种模式。该模式下，对 Service 的访问会通过 iptables 转到 kube-proxy 程序，再由 kube-proxy 程序转发到对应的 Pod 中。</p><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/kube-proxy-userspace.png" alt="在这里插入图片描述"></p><p>这种模式的转发是在用户空间的 kube-proxy 程序中进行到，涉及到用户态和内核态的转换，性能较低，已经不再使用。</p><h5 id="iptables-模式" tabindex="-1"><a class="header-anchor" href="#iptables-模式" aria-hidden="true">#</a> iptables 模式</h5><p>该模式下，kube-proxy 仅负责设置 iptables 转发规则，对于 Service 的访问通过 iptables 规则做 NAT 地址转换，最终随机访问到某个 Pod。该方式避免了用户态到内核态的转换，提升了性能和可靠性。</p><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/kube-proxy-iptables.png" alt="在这里插入图片描述"></p><p>需要注意的是，kube-proxy 在 iptables 模式下运行时，如果所选的第一个 Pod 没有响应， 则连接失败。</p><p>这与 userspace 模式不同，在 userspace 模式下，kube-proxy 如果检测到第一个 Pod 连接失败，其会自动选择其他 Pod 重试。</p><p>可以通过设置 readiness 就绪探针，保证只有正常使用 Pod 可以作为 endpoint 使用，保证 iptables 模式下的 kube-proxy 能访问的都是正常的 Pod，避免将流量通过 kube-proxy 发送到已经发生故障的 Pod 中。</p><p>我们设置 kube-proxy 的 mode 为 <code>iptables</code> 后看下是如何工作的。</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>proxy
  <span class="token key atrule">name</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>proxy
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system
<span class="token key atrule">data</span><span class="token punctuation">:</span>
  <span class="token key atrule">config.conf</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token punctuation">-</span>
    . . . 
    <span class="token key atrule">mode</span><span class="token punctuation">:</span> iptables
    . . . 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先创建一个 Service 代理三个 Nginx Pod。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ kubectl get svc
NAME            TYPE        CLUSTER-IP     EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>   AGE
nginx-service   ClusterIP   <span class="token number">10.233</span>.40.88   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>        <span class="token number">80</span>/TCP    98s

$ kubectl get endpoints
NAME            ENDPOINTS                                      AGE
nginx-service   <span class="token number">10.233</span>.64.4:80,10.233.65.3:80,10.233.66.2:80   102s

$ kubectl get pods <span class="token parameter variable">-o</span> wide
NAME                               READY   STATUS    RESTARTS   AGE    IP            NODE    NOMINATED NODE   READINESS GATES
nginx-deployment-576c6b7b6-6rdhf   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          107s   <span class="token number">10.233</span>.66.2   node3   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>           <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>
nginx-deployment-576c6b7b6-jdt7x   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          107s   <span class="token number">10.233</span>.64.4   node1   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>           <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>
nginx-deployment-576c6b7b6-rrgtc   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          107s   <span class="token number">10.233</span>.65.3   node2   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>           <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建完成后我们看下主机上的 iptables 规则，不妨回忆下数据包在 netfilter 中 HOOK 点:</p><ul><li>本机 or Kubernetes 集群内访问 Service，需要经过 netfilter 的 OUTPUT 点</li><li>集群外访问 Service，需要经过 netfilter 的 PREROUTING 点</li></ul><p>因此 iptables 需要在上述两个点设置规则，将 Service 的 ClusterIP 进转换为 Pod IP ，需要在 nat 表的 PREROUTING 和 OUTPUT 链上设置规则。</p><p>我们来验证下，首先找下 PREROUTING 和 OUTPUT 链上有没有挂载 Service 的规则，我们可以找到如下两条规则：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看 NAT 表的规则</span>
$ <span class="token function">sudo</span> iptables <span class="token parameter variable">-t</span> nat <span class="token parameter variable">-nvL</span>
Chain PREROUTING <span class="token punctuation">(</span>policy ACCEPT <span class="token number">0</span> packets, <span class="token number">0</span> bytes<span class="token punctuation">)</span>
 pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination
 <span class="token number">6173</span>  330K KUBE-SERVICES  all  --  *      *       <span class="token number">0.0</span>.0.0/0            <span class="token number">0.0</span>.0.0/0            /* kubernetes <span class="token function">service</span> portals */


Chain OUTPUT <span class="token punctuation">(</span>policy ACCEPT <span class="token number">0</span> packets, <span class="token number">0</span> bytes<span class="token punctuation">)</span>
 pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination
<span class="token number">12764</span>  792K KUBE-SERVICES  all  --  *      *       <span class="token number">0.0</span>.0.0/0            <span class="token number">0.0</span>.0.0/0            /* kubernetes <span class="token function">service</span> portals */

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两条规则的 source 和 destination 都是 <code>0.0.0.0/0</code>，target 都是 <code>KUBE-SERVICES</code>，表示所有发往本机的包和集群外发往本机的包都会转到 <code>KUBE-SERVICES</code> 链上。</p><p>接下来我们在看下 KUBE-SERVICES 链的规则。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">sudo</span> iptables <span class="token parameter variable">-t</span> nat <span class="token parameter variable">-nvL</span> KUBE-SERVICES <span class="token operator">|</span> <span class="token function">column</span> <span class="token parameter variable">-t</span>
Chain  KUBE-SERVICES  <span class="token punctuation">(</span><span class="token number">2</span>                         references<span class="token punctuation">)</span>
pkts   bytes          target                     prot         opt  <span class="token keyword">in</span>  out  <span class="token builtin class-name">source</span>     destination
<span class="token comment"># 将目标地址为 10.233.40.88(nginx-service 的 ClusterIP) 的包转到 KUBE-SVC-V2OKYYMBY3REGZOG 链</span>
<span class="token number">0</span>      <span class="token number">0</span>              KUBE-SVC-V2OKYYMBY3REGZOG  tcp          --   *   *    <span class="token number">0.0</span>.0.0/0  <span class="token number">10.233</span>.40.88  /*  default/nginx-service        cluster  IP          */
<span class="token number">0</span>      <span class="token number">0</span>              KUBE-SVC-NPX46M4PTMTKRN6Y  tcp          --   *   *    <span class="token number">0.0</span>.0.0/0  <span class="token number">10.233</span>.0.1    /*  default/kubernetes:https     cluster  IP          */
<span class="token number">0</span>      <span class="token number">0</span>              KUBE-SVC-ZRLRAB2E5DTUX37C  udp          --   *   *    <span class="token number">0.0</span>.0.0/0  <span class="token number">10.233</span>.0.3    /*  kube-system/coredns:dns      cluster  IP          */
<span class="token number">0</span>      <span class="token number">0</span>              KUBE-SVC-FAITROITGXHS3QVF  tcp          --   *   *    <span class="token number">0.0</span>.0.0/0  <span class="token number">10.233</span>.0.3    /*  kube-system/coredns:dns-tcp  cluster  IP          */
<span class="token number">0</span>      <span class="token number">0</span>              KUBE-SVC-QKJQYQZXY3DRLPVB  tcp          --   *   *    <span class="token number">0.0</span>.0.0/0  <span class="token number">10.233</span>.0.3    /*  kube-system/coredns:metrics  cluster  IP          */
<span class="token number">8893</span>   493K           KUBE-NODEPORTS             all          --   *   *    <span class="token number">0.0</span>.0.0/0  <span class="token number">0.0</span>.0.0/0     /*  kubernetes                   <span class="token function">service</span>  nodeports<span class="token punctuation">;</span>  NOTE:  this  must  be  the  last  rule  <span class="token keyword">in</span>  this  chain  */  ADDRTYPE  match  dst-type  LOCAL
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到第一条 <code>default/nginx-service</code> 的规则，这个对应到我们的刚创建的 nginx-service ，其 target 是 <code>KUBE-SVC-V2OKYYMBY3REGZOG</code>，因此该包会转到 <code>KUBE-SVC-V2OKYYMBY3REGZOG</code> 链上。继续查看 <code>KUBE-SVC-V2OKYYMBY3REGZOG</code> 链的规则。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">sudo</span> iptables <span class="token parameter variable">-t</span> nat <span class="token parameter variable">-nvL</span> KUBE-SVC-V2OKYYMBY3REGZOG  <span class="token operator">|</span> <span class="token function">column</span> <span class="token parameter variable">-t</span>
Chain  KUBE-SVC-V2OKYYMBY3REGZOG  <span class="token punctuation">(</span><span class="token number">1</span>                         references<span class="token punctuation">)</span>
pkts   bytes                      target                     prot         opt  <span class="token keyword">in</span>  out  <span class="token builtin class-name">source</span>           destination
<span class="token comment"># 对集群外的包标记设置为 0x4000</span>
<span class="token number">0</span>      <span class="token number">0</span>                          KUBE-MARK-MASQ             tcp          --   *   *    <span class="token operator">!</span><span class="token number">10.233</span>.64.0/18  <span class="token number">10.233</span>.40.88  /*  default/nginx-service  cluster  IP              */
<span class="token comment"># 将发到该链的包随机转发到三个链中，iptables 规则是从上到下逐条匹配，因此要设置匹配概率保证每条的匹配规则相同，下面一次是 1/3，1/2 , 1。</span>
<span class="token number">0</span>      <span class="token number">0</span>                          KUBE-SEP-FOSYNTRPSERVNODE  all          --   *   *    <span class="token number">0.0</span>.0.0/0        <span class="token number">0.0</span>.0.0/0     /*  default/nginx-service  -<span class="token operator">&gt;</span>       <span class="token number">10.233</span>.64.4:80  */  statistic  mode  random  probability  <span class="token number">0.33333333349</span>
<span class="token number">0</span>      <span class="token number">0</span>                          KUBE-SEP-2H4DDHMGXF2HFD2H  all          --   *   *    <span class="token number">0.0</span>.0.0/0        <span class="token number">0.0</span>.0.0/0     /*  default/nginx-service  -<span class="token operator">&gt;</span>       <span class="token number">10.233</span>.65.3:80  */  statistic  mode  random  probability  <span class="token number">0.50000000000</span>
<span class="token number">0</span>      <span class="token number">0</span>                          KUBE-SEP-76F2POANROK2TCTZ  all          --   *   *    <span class="token number">0.0</span>.0.0/0        <span class="token number">0.0</span>.0.0/0     /*  default/nginx-service  -<span class="token operator">&gt;</span>       <span class="token number">10.233</span>.66.2:80  */

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到有 3 条规则的注释是带 IP 的，表示将包转发到 PodIP:80，其对应三条 <code>KUBE-SEP-</code> 开头的链，与此同时，其匹配的概率从上到下分别是 0.333，0.5 和 1，这是因为 iptables 规则是从上到下逐条匹配，为了保证每条规则被匹配到的概率一致，因此其概率分别是 1/3，1/2 , 1。</p><p>我们选择其中一条 <code>KUBE-SEP-2H4DDHMGXF2HFD2H</code> 链，查看其规则。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">sudo</span> iptables <span class="token parameter variable">-t</span> nat <span class="token parameter variable">-nvL</span> KUBE-SEP-2H4DDHMGXF2HFD2H  <span class="token operator">|</span> <span class="token function">column</span> <span class="token parameter variable">-t</span>
Chain  KUBE-SEP-2H4DDHMGXF2HFD2H  <span class="token punctuation">(</span><span class="token number">1</span>              references<span class="token punctuation">)</span>
pkts   bytes                      target          prot         opt  <span class="token keyword">in</span>  out  <span class="token builtin class-name">source</span>       destination
<span class="token number">0</span>      <span class="token number">0</span>                          KUBE-MARK-MASQ  all          --   *   *    <span class="token number">10.233</span>.65.3  <span class="token number">0.0</span>.0.0/0    /*  default/nginx-service  */
<span class="token number">0</span>      <span class="token number">0</span>                          DNAT            tcp          --   *   *    <span class="token number">0.0</span>.0.0/0    <span class="token number">0.0</span>.0.0/0    /*  default/nginx-service  */  tcp  to:10.233.65.3:80
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到该链的 target 是 <code>DNAT</code>，表示将包的目的地址转换为 <code>10.233.65.3:80</code>，也就是 PodIP 地址和端口。最终，网络包的 destination 是 Pod 的 IP 地址和端口，从而完成请求的转发。</p><p>除了 3 条负责转发到 Pod 的规则，KUBE-SVC-V2OKYYMBY3REGZOG 下还有一条 target 为 KUBE-MARK-MASQ 的规则：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">sudo</span> iptables <span class="token parameter variable">-t</span> nat <span class="token parameter variable">-nvL</span> KUBE-SVC-V2OKYYMBY3REGZOG  <span class="token operator">|</span> <span class="token function">column</span> <span class="token parameter variable">-t</span>
Chain  KUBE-SVC-V2OKYYMBY3REGZOG  <span class="token punctuation">(</span><span class="token number">1</span>                         references<span class="token punctuation">)</span>
pkts   bytes                      target                     prot         opt  <span class="token keyword">in</span>  out  <span class="token builtin class-name">source</span>           destination
<span class="token number">0</span>      <span class="token number">0</span>                          KUBE-MARK-MASQ             tcp          --   *   *    <span class="token operator">!</span><span class="token number">10.233</span>.64.0/18  <span class="token number">10.233</span>.40.88  /*  default/nginx-service  cluster  IP              */


$ <span class="token function">sudo</span> iptables <span class="token parameter variable">-t</span> nat <span class="token parameter variable">-nvL</span> KUBE-MARK-MASQ  <span class="token operator">|</span> <span class="token function">column</span> <span class="token parameter variable">-t</span>
Chain  KUBE-MARK-MASQ  <span class="token punctuation">(</span><span class="token number">16</span>     references<span class="token punctuation">)</span>
pkts   bytes           target  prot         opt  <span class="token keyword">in</span>  out  <span class="token builtin class-name">source</span>     destination
<span class="token number">0</span>      <span class="token number">0</span>               MARK    all          --   *   *    <span class="token number">0.0</span>.0.0/0  <span class="token number">0.0</span>.0.0/0    MARK  or  0x4000
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到规则匹配的 source 是 <code>!10.233.64.0/18</code>，表示匹配的源地址不是 <code>10.233.64.0/18</code> 的地址，也就是非集群内的地址。这条规则表示来自集群外的请求，并且目标 IP 是 nginx-service 的 ClusterIP 的包会转发到 KUBE-MARK-MASQ 链上，然后该链的 target 是 <code>MARK</code>，表示将包的标记设置为 <code>0x4000</code>，被标记的包后续会由 KUBE-POSTROUTING 链做 SNAT 处理，处理方式是将响应包的源地址（Pod IP）转换为主机 的 IP 地址，然后主机将响应包发送到请求的客户端。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ sudo iptables -t nat -nvL KUBE-POSTROUTING  | column -t
Chain  KUBE-POSTROUTING  (1          references)
pkts   bytes             target      prot         opt  in  out  source     destination
14055  859K              RETURN      all          --   *   *    0.0.0.0/0  0.0.0.0/0
0      0                 MARK        all          --   *   *    0.0.0.0/0  0.0.0.0/0    MARK  xor         0x4000
0      0                 MASQUERADE  all          --   *   *    0.0.0.0/0  0.0.0.0/0    /*    kubernetes  service  traffic  requiring  SNAT  */  random-fully
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的转发规则可以看出，Service 的 ClusterIP 本质上是 iptables 规则中的一个 IP ，在 Node 中是没有对应的网络设备的，因此在 Node 上 ping 该 IP 是 ping 不通的。</p><h5 id="ipvs-模式" tabindex="-1"><a class="header-anchor" href="#ipvs-模式" aria-hidden="true">#</a> ipvs 模式</h5>`,50)),s("p",null,[n[41]||(n[41]=a("根据 K8s 官方博客 ",-1)),s("a",A,[n[40]||(n[40]=a("IPVS-Based In-Cluster Load Balancing Deep Dive",-1)),t(e)]),n[42]||(n[42]=a(" 介绍，iptables 本质还是为了防火墙目的而设计的，其基于内核规则列表工作。这使得随着 K8s 集群的增大，kube-proxy 成为了集群扩展的瓶颈，随着节点、Pod、Service 增多，iptables 规则也越来越多，在做消息转发时的效率也就越低，因此又出现了 ipvs 模式来解决扩展性的问题。",-1))]),n[76]||(n[76]=s("p",null,"ipvs 模式基于内核的 LVS（Linux Virtual Server）模块，最早在 1998 由章文嵩博士开发，并在 2004 年在 Linux 2.4 内核中被采纳。",-1)),n[77]||(n[77]=s("p",null,"LVS 也是基于 netfilter 框架，通过修改 MAC 层、IP 层、TCP 层的数据包，实现了交换机和网关的功能。",-1)),n[78]||(n[78]=s("p",null,[s("img",{src:"https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/nf-lvs.png",alt:"在这里插入图片描述"})],-1)),s("p",null,[n[44]||(n[44]=a("图片来自 ",-1)),s("a",I,[n[43]||(n[43]=a("LVS-HOWTO",-1)),t(e)])]),n[79]||(n[79]=l(`<p>关于 LVS 的更多细节可以参考相关文档，这里我们只关注 kube-proxy 的具体使用。</p><p>kube-proxy 会监视 Kubernetes 服务和端点，调用 netlink 接口相应地创建 IPVS 规则， 并定期将 IPVS 规则与 Kubernetes 服务和端点同步。 该控制循环可确保 IPVS 状态与所需状态匹配。访问服务时，IPVS 默认采用轮询的方式将流量定向到后端Pod之一。</p><p>与 iptables 模式相比，IPVS 模式下的 kube-proxy 重定向通信的延迟要短，并且在同步代理规则时具有更好的性能。与其他代理模式相比，IPVS 模式还支持更高的网络流量吞吐量。</p><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/kube-proxy-ipvs.png" alt="在这里插入图片描述"></p><p>我们将 kube-proxy 配置为 ipvs 模式后看下具体的实现细节。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ kubectl edit configmap kube-proxy <span class="token parameter variable">-n</span> kube-system
// change mode from <span class="token string">&quot;&quot;</span> to ipvs
mode: ipvs
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还是以上面的 Service 为例，除了 nginx-service 这里还有 coredns 和 kubernetes 两个 Service。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ kubectl get svc <span class="token parameter variable">-o</span> wide <span class="token parameter variable">-A</span>
NAMESPACE   NAME            TYPE        CLUSTER-IP     EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>   AGE     SELECTOR
default     kubernetes      ClusterIP   <span class="token number">10.233</span>.0.1     <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>        <span class="token number">443</span>/TCP                  18h     <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>
default     nginx-service   ClusterIP   <span class="token number">10.233</span>.29.12   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>        <span class="token number">80</span>/TCP                   4m35s   <span class="token assign-left variable">app</span><span class="token operator">=</span>nginx
kube-system   coredns         ClusterIP   <span class="token number">10.233</span>.0.3     <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>        <span class="token number">53</span>/UDP,53/TCP,9153/TCP   18h     k8s-app<span class="token operator">=</span>kube-dns

$ kubectl get pods <span class="token parameter variable">-o</span> wide
NAME                               READY   STATUS    RESTARTS   AGE    IP               NODE    NOMINATED NODE   READINESS GATES
nginx-deployment-576c6b7b6-jzkf9   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          3m3s   <span class="token number">10.233</span>.75.2      node2   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>           <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>
nginx-deployment-576c6b7b6-mxvkl   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          3m3s   <span class="token number">10.233</span>.71.2      node3   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>           <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>
nginx-deployment-576c6b7b6-xcxqx   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          3m3s   <span class="token number">10.233</span>.102.131   node1   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>           <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>IPVS &amp; IPSet</strong></p><p>在 IPVS 模式下，kube-proxy 会做下面一些事情：</p><ul><li>创建一个虚拟网络设备 kube-ipvs0 ，所有 Service 的 IP 会加到该设备上。</li><li>创建 ipset，将 Service 的 IP 加到 ipset 中。</li><li>创建 iptables 规则，辅助流量转发。</li></ul><p>ipset 会维护 3 个列表：</p><table><thead><tr><th>set 名</th><th>成员信息</th><th>作用</th></tr></thead><tbody><tr><td>KUBE-CLUSTER-IP</td><td>ClusterIP 类型的 Service 的 ClusterIP + Port</td><td></td></tr><tr><td>KUBE-NODE-PORT-TCP</td><td>NodePort 类型的 Service 指定的 TCP 端口</td><td></td></tr><tr><td>KUBE-NODE-PORT-UDP</td><td>NodePort 类型的 Service 指定的 UDP 端口</td><td></td></tr></tbody></table><p>我们看下 node1 的虚拟网卡和 ipset 信息，可以看到上面的 3 个 Service 的 IP 都加到了 kube-ipvs0 设备上，ipset 中也有对应的 IP 和端口信息。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">ip</span> addr
<span class="token number">28</span>: kube-ipvs0: <span class="token operator">&lt;</span>BROADCAST,NOARP<span class="token operator">&gt;</span> mtu <span class="token number">1500</span> qdisc noop state DOWN group default
    link/ether ba:2c:1d:78:ae:f5 brd ff:ff:ff:ff:ff:ff
    inet <span class="token number">10.233</span>.0.1/32 scope global kube-ipvs0
       valid_lft forever preferred_lft forever
    inet <span class="token number">10.233</span>.0.3/32 scope global kube-ipvs0
       valid_lft forever preferred_lft forever
    inet <span class="token number">10.233</span>.29.12/32 scope global kube-ipvs0 <span class="token comment"># nginx-service 的 ClusterIP</span>
       valid_lft forever preferred_lft forever

$ <span class="token function">sudo</span> ipset list KUBE-CLUSTER-IP
Name: KUBE-CLUSTER-IP
Type: hash:ip,port
Revision: <span class="token number">6</span>
Header: family inet hashsize <span class="token number">1024</span> maxelem <span class="token number">65536</span> bucketsize <span class="token number">12</span> initval 0x15dd7a3f
Size <span class="token keyword">in</span> memory: <span class="token number">488</span>
References: <span class="token number">3</span>
Number of entries: <span class="token number">6</span>
Members:
<span class="token number">10.233</span>.29.12,tcp:80 <span class="token comment"># nginx-service 的 ClusterIP:Port</span>
<span class="token number">10.233</span>.0.1,tcp:443
<span class="token number">10.233</span>.32.167,tcp:80
<span class="token punctuation">..</span>.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>既然 Service 的 IP 都加到 kube-ipvs0 设备上，那么请求 Service IP 的包就会发到 kube-ipvs0 设备上，基于 IPVS 的规则进行转发。可以看到 nginx-service 的 IP 对应的 3 个 Pod 的 IP，其转发策略是 <code>rr</code>，即 Round Robin 轮询，因此请求会均匀的转发到 3 个 Pod 上。下面是对应的 ipvs 规则。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ sudo ipvsadm -Ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn

TCP  10.233.29.12:80 rr # nginx-service 的 IP
   # 3个 Pod 的 IP
  -&gt; 10.233.71.2:80               Masq    1      0          0
  -&gt; 10.233.75.2:80               Masq    1      0          0
  -&gt; 10.233.102.131:80            Masq    1      0          0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基于上述过程，我们发现在 IPVS 模式下好像不需要 iptables 的规则，那么 iptables 的规则是做什么用的呢？我们来看下，首先还是在 nat 表的 PREROUTING 和 OUTPUT 链上将所有请求转到 <code>KUBE-SERVICES</code> 链。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ sudo iptables -t nat -nvL
Chain PREROUTING (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination
 107K 5093K KUBE-SERVICES  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes service portals */


Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination
 296K   18M KUBE-SERVICES  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes service portals */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在查看下 <code>KUBE-SERVICES</code> 链的规则：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">sudo</span> iptables <span class="token parameter variable">-t</span> nat <span class="token parameter variable">-nvL</span> KUBE-SERVICES <span class="token operator">|</span> <span class="token function">column</span> <span class="token parameter variable">-t</span>
Chain  KUBE-SERVICES  <span class="token punctuation">(</span><span class="token number">2</span>              references<span class="token punctuation">)</span>
pkts   bytes          target          prot         opt  <span class="token keyword">in</span>  out  <span class="token builtin class-name">source</span>           destination
<span class="token number">3</span>      <span class="token number">180</span>            RETURN          all          --   *   *    <span class="token number">127.0</span>.0.0/8      <span class="token number">0.0</span>.0.0/0
<span class="token number">0</span>      <span class="token number">0</span>              KUBE-MARK-MASQ  all          --   *   *    <span class="token operator">!</span><span class="token number">10.233</span>.64.0/18  <span class="token number">0.0</span>.0.0/0    /*         Kubernetes       <span class="token function">service</span>   cluster  <span class="token function">ip</span>  +  port  <span class="token keyword">for</span>  masquerade  purpose  */  match-set  KUBE-CLUSTER-IP  dst,dst
<span class="token number">57</span>     <span class="token number">3068</span>           KUBE-NODE-PORT  all          --   *   *    <span class="token number">0.0</span>.0.0/0        <span class="token number">0.0</span>.0.0/0    ADDRTYPE   match            dst-type  LOCAL
<span class="token number">0</span>      <span class="token number">0</span>              ACCEPT          all          --   *   *    <span class="token number">0.0</span>.0.0/0        <span class="token number">0.0</span>.0.0/0    match-set  KUBE-CLUSTER-IP  dst,dst

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到这里不再像 iptables 模式下那样有每个 Service 对应的规则，而是只有几条规则：</p><ul><li>第一条：其匹配的源地址是 127.0.0.0/8，也就是本地的请求，target return 会直接返回到上一级链继续匹配。</li><li>第二条：对非集群内的包标记设置为 <code>0x4000</code>，被标记的包后续会由 KUBE-POSTROUTING 链做 SNAT 处理，处理方式是将响应包的源地址（Pod IP）转换为主机的 IP 地址，然后主机将响应包发送到请求的客户端。</li><li>第三条：表示将目标地址为本地的请求转发到 KUBE-NODE-PORT 链上。</li><li>第四条：match-set 的意思是匹配某个 ipset 集合，这里表示任意匹配了 <code>KUBE-CLUSTER-IP</code> 的 set 的包，target 是 ACCEPT，表示允许转发。因此所有请求 Service 的包都会被放行。可以看到，IPVS 模式下，iptables 的规则只是用来标记和放行，不需要像 iptables 模式那样为每个 Service 创建规则并基于概率做负载均衡，真正的负载均衡是基于 IPVS 实现的。</li></ul>`,23)),s("p",null,[n[46]||(n[46]=a("和 iptables 模式下需要遍历规则相比，ipvs 直接使用哈希查找，时间复杂度有 O(N)变为 O（1），由此性能得到明显的提升。下图是 iptables 与 ipvs 模式的性能对比，可以看到在 10000 节点的集群上，ipvs 模式比 iptables 模式性能几乎高一倍。因此在大规模集群中一般都会推荐使用 IPVS 模式。 ",-1)),n[47]||(n[47]=s("img",{src:"https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/ipvs-iptables.png",alt:"在这里插入图片描述"},null,-1)),n[48]||(n[48]=a(" 图片来自：",-1)),s("a",C,[n[45]||(n[45]=a("Comparing kube-proxy modes: iptables or IPVS?",-1)),t(e)])]),n[80]||(n[80]=l('<h3 id="ingress-与-gateway" tabindex="-1"><a class="header-anchor" href="#ingress-与-gateway" aria-hidden="true">#</a> Ingress 与 Gateway</h3><p>Service 只能在集群内做负载均衡，如果我们的服务需要被外部访问，Service 本身提供了 NodePort 和 LoadBalancer 两种类型的 Service 可以直接对外提供访问。</p><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/250904-ingress-003.png" alt="在这里插入图片描述"></p><p>但这种方式有一些局限性：</p><ul><li>NodePort 方式需要在每个节点上开放端口，且端口号范围是 30000-32767 之间，端口数量有限。</li><li>LoadBalancer 方式需要云厂商支持，且每个 Service 都会创建一个负载均衡实例，浪费资源且成本较高。</li><li>两种方式都只能基于四层（TCP/UDP）做负载均衡，无法基于七层（HTTP/HTTPS）做路由转发。</li></ul><p>因此为了解决上述问题，Kubernetes 提供了 Ingress 和 Gateway 两种方式来对外提供服务。我们首先来看下</p><p>在 Kubernetes 中部署的服务如果想被外部访问，主要有三种方式：</p><ul><li><p>NodePort Service：在每个节点上开端口供外部访问。</p></li><li><p>LoadBanlacer Service：使用云厂商提供的负载均衡对外提供服务。 <img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/250904-ingress-002.png" alt="在这里插入图片描述"></p></li><li><p>Ingress：Kubernetes 提供的七层流量转发方案。</p></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/00ea577fadf9d596b576a982e63fb038.png" alt="在这里插入图片描述"></p><p>图片来自 https://matthewpalmer.net/kubernetes-app-developer/articles/kubernetes-ingress-guide-nginx-example.html</p>',10)),s("p",null,[n[50]||(n[50]=a("Ingress 就是“服务的服务”，本质上就是对反向代理的抽象。Ingress 的使用需要 Ingress Controller，可以安装标准的 ",-1)),s("a",R,[n[49]||(n[49]=a("Nginx Ingress Controller",-1)),t(e)]),n[51]||(n[51]=a("，相当于在 Kubernetes 里装一个 Nginx 为业务服务做反向代理负。",-1))]),n[81]||(n[81]=l(`<p>Ingress 示例如下：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>wildcard<span class="token punctuation">-</span>host
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">rules</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> <span class="token string">&quot;foo.bar.com&quot;</span>
    <span class="token key atrule">http</span><span class="token punctuation">:</span>
      <span class="token key atrule">paths</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">pathType</span><span class="token punctuation">:</span> Prefix
        <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token string">&quot;/bar&quot;</span>
        <span class="token key atrule">backend</span><span class="token punctuation">:</span>
          <span class="token key atrule">service</span><span class="token punctuation">:</span>
            <span class="token key atrule">name</span><span class="token punctuation">:</span> service1
            <span class="token key atrule">port</span><span class="token punctuation">:</span>
              <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">80</span>
  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> <span class="token string">&quot;*.foo.com&quot;</span>
    <span class="token key atrule">http</span><span class="token punctuation">:</span>
      <span class="token key atrule">paths</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">pathType</span><span class="token punctuation">:</span> Prefix
        <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token string">&quot;/foo&quot;</span>
        <span class="token key atrule">backend</span><span class="token punctuation">:</span>
          <span class="token key atrule">service</span><span class="token punctuation">:</span>
            <span class="token key atrule">name</span><span class="token punctuation">:</span> service2
            <span class="token key atrule">port</span><span class="token punctuation">:</span>
              <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">80</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Host: 配置的 host 信息，如果为空表示可以接收任何请求流量。如果设置，比如上面规则设置了 &quot;foo.bar.com&quot; 则 Ingress 规则只作用于请求 &quot;foo.bar.com&quot; 的请求。</li><li>pathType: 必填字段，表示路径匹配的类型。 <ul><li>Exact：精确匹配 URL 路径，且区分大小写。</li><li>Prefix：基于以 / 分隔的 URL 路径前缀匹配。匹配区分大小写，并且对路径中的元素逐个完成。 路径元素指的是由 / 分隔符分隔的路径中的标签列表。 如果每个 p 都是请求路径 p 的元素前缀，则请求与路径 p 匹配。</li></ul></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6f079d635fb6f8dfb0b3b0c7bb915fa7.png" alt="在这里插入图片描述"></p><p>Ingress 创建后相当于在 Nginx Ingress Controller 里面创建配置，和我们日常使用 Nginx 添加配置没有区别。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">## start server *.foo.com</span>
	server <span class="token punctuation">{</span>
		server_name *.foo.com<span class="token punctuation">;</span>

		listen <span class="token number">80</span><span class="token punctuation">;</span>

		<span class="token builtin class-name">set</span> <span class="token variable">$proxy_upstream_name</span> <span class="token string">&quot;-&quot;</span><span class="token punctuation">;</span>

		listen <span class="token number">443</span>  ssl http2<span class="token punctuation">;</span>

		<span class="token comment"># PEM sha: 2d165d45c7f24c8a4df64a740666f02378fc8828</span>
		ssl_certificate                         /etc/ingress-controller/ssl/default-fake-certificate.pem<span class="token punctuation">;</span>
		ssl_certificate_key                     /etc/ingress-controller/ssl/default-fake-certificate.pem<span class="token punctuation">;</span>
                      location ~* <span class="token string">&quot;^/foo&quot;</span> <span class="token punctuation">{</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_6-1-fanout" tabindex="-1"><a class="header-anchor" href="#_6-1-fanout" aria-hidden="true">#</a> 6.1 fanout</h4><p>所谓 fanout 指的是在同一个域名下，基于 HTTP URL 匹配将请求发送给不同的服务。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5aec380cb62d8f02b3734f10e00328ff.png" alt="在这里插入图片描述"></p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> simple<span class="token punctuation">-</span>fanout<span class="token punctuation">-</span>example
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">rules</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> foo.bar.com
    <span class="token key atrule">http</span><span class="token punctuation">:</span>
      <span class="token key atrule">paths</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span> /foo
        <span class="token key atrule">pathType</span><span class="token punctuation">:</span> Prefix
        <span class="token key atrule">backend</span><span class="token punctuation">:</span>
          <span class="token key atrule">service</span><span class="token punctuation">:</span>
            <span class="token key atrule">name</span><span class="token punctuation">:</span> service1
            <span class="token key atrule">port</span><span class="token punctuation">:</span>
              <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">4200</span>
      <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span> /bar
        <span class="token key atrule">pathType</span><span class="token punctuation">:</span> Prefix
        <span class="token key atrule">backend</span><span class="token punctuation">:</span>
          <span class="token key atrule">service</span><span class="token punctuation">:</span>
            <span class="token key atrule">name</span><span class="token punctuation">:</span> service2
            <span class="token key atrule">port</span><span class="token punctuation">:</span>
              <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">8080</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_6-2-常用注解" tabindex="-1"><a class="header-anchor" href="#_6-2-常用注解" aria-hidden="true">#</a> 6.2 常用注解</h4><p><strong>rewrite-target</strong></p><p>用来重定向 URL</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1beta1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>
    <span class="token key atrule">nginx.ingress.kubernetes.io/rewrite-target</span><span class="token punctuation">:</span> /$2
  <span class="token key atrule">name</span><span class="token punctuation">:</span> rewrite
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">rules</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> rewrite.bar.com
    <span class="token key atrule">http</span><span class="token punctuation">:</span>
      <span class="token key atrule">paths</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">backend</span><span class="token punctuation">:</span>
          <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> http<span class="token punctuation">-</span>svc
          <span class="token key atrule">servicePort</span><span class="token punctuation">:</span> <span class="token number">80</span>
        <span class="token key atrule">path</span><span class="token punctuation">:</span> /something(/<span class="token punctuation">|</span>$)(.<span class="token important">*)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在此入口定义中，需要在 path 用正则表达式匹配字符，匹配的值会赋值给 $1、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>…</mo></mrow><annotation encoding="application/x-tex">2…</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span></span></span></span>n 等占位符。在上面的表达式中 (.*) 捕获的任何字符都将分配给占位符$2，然后将其用作 rewrite-target 注释中的参数来修改 URL。</p><p>例如，上面的入口定义将导致以下重写：</p><ul><li>rewrite.bar.com/something 重写为 rewrite.bar.com/</li><li>rewrite.bar.com/something/ 重写为 rewrite.bar.com/</li><li>rewrite.bar.com/something/new 重写为 rewrite.bar.com/new</li></ul><p><strong>App Root</strong></p><p>重定向时指定对于在 “/” 路径下的请求重定向其根路径为注解的值。示例如下，注解值为 /app1 则请求 URL 由原来的的 / 重定向为了 /app1。</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1beta1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>
    <span class="token key atrule">nginx.ingress.kubernetes.io/app-root</span><span class="token punctuation">:</span> /app1
  <span class="token key atrule">name</span><span class="token punctuation">:</span> approot
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">rules</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> approot.bar.com
    <span class="token key atrule">http</span><span class="token punctuation">:</span>
      <span class="token key atrule">paths</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">backend</span><span class="token punctuation">:</span>
          <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> http<span class="token punctuation">-</span>svc
          <span class="token key atrule">servicePort</span><span class="token punctuation">:</span> <span class="token number">80</span>
        <span class="token key atrule">path</span><span class="token punctuation">:</span> /
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>检查</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code>$ curl <span class="token punctuation">-</span>I <span class="token punctuation">-</span>k http<span class="token punctuation">:</span>//approot.bar.com/
HTTP/1.1 302 Moved Temporarily
<span class="token key atrule">Server</span><span class="token punctuation">:</span> nginx/1.11.10
<span class="token key atrule">Date</span><span class="token punctuation">:</span> Mon<span class="token punctuation">,</span> 13 Mar 2017 14<span class="token punctuation">:</span>57<span class="token punctuation">:</span>15 GMT
<span class="token key atrule">Content-Type</span><span class="token punctuation">:</span> text/html
<span class="token key atrule">Content-Length</span><span class="token punctuation">:</span> <span class="token number">162</span>
<span class="token key atrule">Location</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//stickyingress.example.com/app1
<span class="token key atrule">Connection</span><span class="token punctuation">:</span> keep<span class="token punctuation">-</span>alive
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>上传文件限制</strong></p><p>外部通过 Nginx 上传文件时会有上传大小限制，在 Nginx Ingress Controller 中该限制默认是 8M，由 proxy-body-size 注解控制：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>nginx.ingress.kubernetes.io/proxy-body-size: 8m
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以在创建 Ingress 时设置</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>
    <span class="token key atrule">nginx.ingress.kubernetes.io/proxy-body-size</span><span class="token punctuation">:</span> 80m
  <span class="token key atrule">name</span><span class="token punctuation">:</span> gateway
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default

<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">rules</span><span class="token punctuation">:</span>
<span class="token punctuation">...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_6-4-启用tls" tabindex="-1"><a class="header-anchor" href="#_6-4-启用tls" aria-hidden="true">#</a> 6.4 启用TLS</h4><p>部署好 NGINX Ingress Controller 后，它会在 Kubernetes 中开启 NodePort 类型的服务，</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ kubectl get svc <span class="token parameter variable">-n</span> ingress-nginx
NAME                                 TYPE        CLUSTER-IP       EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>                      AGE
ingress-nginx-controller             NodePort    <span class="token number">10.107</span>.127.108   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>        <span class="token number">80</span>:32556/TCP,443:30692/TCP   25d
ingress-nginx-controller-admission   ClusterIP   <span class="token number">10.111</span>.3.4       <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>        <span class="token number">443</span>/TCP                      25d
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们从外部访问该端口时请求就会根据 Ingress 规则转发到对应的服务中。为了数据安全，外部到服务的请求基本上都需要进行 HTTPS 加密，和我们在没用 Kubernetes 时需要在主机上配置 Nginx 的 HTTPS 一样，我们也需要让我们的 Ingress 支持 HTTPS 。</p><p>以自签名证书为例，配置 Ingress 支持 HTTPS 分三步：</p><p><strong>生成证书</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ openssl req <span class="token parameter variable">-x509</span> <span class="token parameter variable">-sha256</span> <span class="token parameter variable">-nodes</span> <span class="token parameter variable">-days</span> <span class="token number">365</span> <span class="token parameter variable">-newkey</span> rsa:2048 <span class="token punctuation">\\</span>
      <span class="token parameter variable">-keyout</span> tls.key <span class="token parameter variable">-out</span> tls.crt <span class="token parameter variable">-subj</span> <span class="token string">&quot;/CN=foo.bar.com/O=httpsvc&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>创建 TLS 类型的 secret</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ kubectl create secret tls tls-secret <span class="token parameter variable">--key</span> tls.key <span class="token parameter variable">--cert</span> tls.crt
secret <span class="token string">&quot;tls-secret&quot;</span> created
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>创建 ingress 并设置 TLS</strong></p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1beta1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>test
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">tls</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> foo.bar.com
      <span class="token comment"># This assumes tls-secret exists and the SSL</span>
      <span class="token comment"># certificate contains a CN for foo.bar.com</span>
      <span class="token key atrule">secretName</span><span class="token punctuation">:</span> tls<span class="token punctuation">-</span>secret
  <span class="token key atrule">rules</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> foo.bar.com
      <span class="token key atrule">http</span><span class="token punctuation">:</span>
        <span class="token key atrule">paths</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span> /
          <span class="token key atrule">backend</span><span class="token punctuation">:</span>
            <span class="token comment"># This assumes http-svc exists and routes to healthy endpoints</span>
            <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> httpsvc
            <span class="token key atrule">servicePort</span><span class="token punctuation">:</span> <span class="token number">80</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样在请求 foo.bar.com 时就可以使用 HTTPS 请求了。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ kubectl get ing ingress-tls
NAME          CLASS    HOSTS         ADDRESS        PORTS     AGE
ingress-tls   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>   foo.bar.com   <span class="token number">192.168</span>.64.7   <span class="token number">80</span>, <span class="token number">443</span>   38s


$ kubectl get ing ingress-tls <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-v</span> NAME <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">&#39;{print $4, $3}&#39;</span>
<span class="token number">192.168</span>.64.7 foo.bar.com
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编辑 /etc/hosts ，加入 192.168.64.7 foo.bar.com</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">curl</span> <span class="token parameter variable">-k</span> https://foo.bar.com 
<span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>html<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>head<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>title<span class="token operator">&gt;</span>Welcome to nginx<span class="token operator">!</span><span class="token operator">&lt;</span>/title<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>style<span class="token operator">&gt;</span>
    body <span class="token punctuation">{</span>
        width: 35em<span class="token punctuation">;</span>
        margin: <span class="token number">0</span> auto<span class="token punctuation">;</span>
        font-family: Tahoma, Verdana, Arial, sans-serif<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token operator">&lt;</span>/style<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/head<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>body<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>h<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>Welcome to nginx<span class="token operator">!</span><span class="token operator">&lt;</span>/h<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>
<span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.<span class="token operator">&lt;</span>/p<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>For online documentation and support please refer to
<span class="token operator">&lt;</span>a <span class="token assign-left variable">href</span><span class="token operator">=</span><span class="token string">&quot;http://nginx.org/&quot;</span><span class="token operator">&gt;</span>nginx.org<span class="token operator">&lt;</span>/a<span class="token operator">&gt;</span>.<span class="token operator">&lt;</span>br/<span class="token operator">&gt;</span>
Commercial support is available at
<span class="token operator">&lt;</span>a <span class="token assign-left variable">href</span><span class="token operator">=</span><span class="token string">&quot;http://nginx.com/&quot;</span><span class="token operator">&gt;</span>nginx.com<span class="token operator">&lt;</span>/a<span class="token operator">&gt;</span>.<span class="token operator">&lt;</span>/p<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>p<span class="token operator">&gt;</span><span class="token operator">&lt;</span>em<span class="token operator">&gt;</span>Thank you <span class="token keyword">for</span> using nginx.<span class="token operator">&lt;</span>/em<span class="token operator">&gt;</span><span class="token operator">&lt;</span>/p<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/body<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/html<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="dns-for-service" tabindex="-1"><a class="header-anchor" href="#dns-for-service" aria-hidden="true">#</a> DNS for Service</h3><p>Kubernetes 中 Service 的虚拟 IP、Port 也是会发生变化的，我们不能使用这种变化的 IP 与端口作为访问入口。K8S 内部提供了 DNS 服务，为 Service 提供域名，只要 Service 名不变，其域名就不会变。</p><p>Kubernetes 目前使用 CoreDNS 来实现 DNS 功能，其包含一个内存态的 DNS，其本质也是一个 控制器。CoreDNS 监听 Service、Endpoints 的变化并配置更新 DNS 记录，Pod 在解析域名时会从 CoreDNS 中查询到 IP 地址。 <img src="https://i-blog.csdnimg.cn/blog_migrate/a123ec67f8eef868813255fb3b5a7109.png" alt="在这里插入图片描述"></p><h4 id="_7-1-普通-service" tabindex="-1"><a class="header-anchor" href="#_7-1-普通-service" aria-hidden="true">#</a> 7.1 普通 Service</h4><p>对于 ClusterIP / NodePort / LoadBalancer 类型的 Service，Kuberetes 会创建 FQDN 格式为 <code>$svcname.$namespace.svc.$clusterdomain</code> 的 A/AAAA（域名到 IP） 记录和 PRT（IP到域名） 记录。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ kubectl get svc kubia
NAME    TYPE        CLUSTER-IP     EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>   AGE
kubia   ClusterIP   <span class="token number">10.99</span>.166.60   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>        <span class="token number">80</span>/TCP    47h


$ kubectl get pods
NAME                      READY   STATUS    RESTARTS   AGE
kubia-5bb46d6998-jjlgn    <span class="token number">1</span>/1     Running   <span class="token number">0</span>          2m25s
kubia-5bb46d6998-jtpc9    <span class="token number">1</span>/1     Running   <span class="token number">0</span>          14h
kubia-5bb46d6998-mnlvj    <span class="token number">1</span>/1     Running   <span class="token number">0</span>          2m25s

~  <span class="token function">nslookup</span> kubia.default
Server:		<span class="token number">10.96</span>.0.10
Address:	<span class="token number">10.96</span>.0.10<span class="token comment">#53</span>

Name:	kubia.default.svc.cluster.local
Address: <span class="token number">10.99</span>.166.60

 ~  <span class="token function">nslookup</span> <span class="token number">10.99</span>.166.60
<span class="token number">60.166</span>.99.10.in-addr.arpa	name <span class="token operator">=</span> kubia.default.svc.cluster.local.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_7-2-headless-service" tabindex="-1"><a class="header-anchor" href="#_7-2-headless-service" aria-hidden="true">#</a> 7.2 Headless Service</h4><p>对于无头服务，没有 ClusterIP，Kubernetes 会对 Service 创建 A 记录，但返回的所有 Pod 的 IP。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>~  <span class="token function">nslookup</span> kubia-headless.default
Server:		<span class="token number">10.96</span>.0.10
Address:	<span class="token number">10.96</span>.0.10<span class="token comment">#53</span>

Name:	kubia-headless.default.svc.cluster.local
Address: <span class="token number">10.44</span>.0.6
Name:	kubia-headless.default.svc.cluster.local
Address: <span class="token number">10.44</span>.0.5
Name:	kubia-headless.default.svc.cluster.local
Address: <span class="token number">10.44</span>.0.3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_7-3-pod" tabindex="-1"><a class="header-anchor" href="#_7-3-pod" aria-hidden="true">#</a> 7.3 Pod</h4><p>对于 Pod 会创建基于地址的 DNS 记录，格式为 <code>pod-ip.svc-name.namespace-name.svc.cluster.local</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ kubectl get pods <span class="token parameter variable">-o</span> wide
NAME                      READY   STATUS        RESTARTS   AGE     IP           NODE            NOMINATED NODE   READINESS GATES

kubia-5bb46d6998-jtpc9    <span class="token number">1</span>/1     Running       <span class="token number">0</span>          28h     <span class="token number">10.44</span>.0.3


bash-5.1<span class="token comment"># nslookup 10.44.0.3</span>
<span class="token number">3.0</span>.44.10.in-addr.arpa	name <span class="token operator">=</span> <span class="token number">10</span>-44-0-3.kubia-headless.default.svc.cluster.local.
<span class="token number">3.0</span>.44.10.in-addr.arpa	name <span class="token operator">=</span> <span class="token number">10</span>-44-0-3.kubia.default.svc.cluster.local.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,54))])}const w=i(c,[["render",U],["__file","network.html.vue"]]);export{w as default};
