import{_ as n,c as a,o as e,a as t}from"./app-C-eiXR-Q.js";const o={};function p(r,s){return e(),a("div",null,[...s[0]||(s[0]=[t(`<h1 id="指标" tabindex="-1"><a class="header-anchor" href="#指标" aria-hidden="true">#</a> 指标</h1><p>在指标领域，基于 Prometheus 的指标收集与存储，已经是事实上的标准，因此本节内容主要围绕 Prometheus 做简要的介绍。</p><h2 id="指标的收集" tabindex="-1"><a class="header-anchor" href="#指标的收集" aria-hidden="true">#</a> 指标的收集</h2><p>Prometheus 整体架构如图，其通过 pull（拉取）的方式收集被监控对象的指标数据，并将其存储在 TSDB（时序数据库）中。在配合 Grafana 和 AlertManager，实现数据的可视化和告警。</p><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/prometheus-arch.png" alt="Prometheus Architecture"></p><p>围绕指标的收集，Prometheus 使用 Exporter 作为系统与被监控对象之间的桥梁，由 Exporter 实现具体的指标收集并暴露 <code>/metrics</code> 接口，供 Prometheus 拉取。比如下面是 Node Exporter 收集主机 CPU 指标的示例：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">curl</span> http://127.0.0.1:9100/metrics <span class="token operator">|</span> <span class="token function">grep</span> node_cpu_seconds_total
<span class="token comment"># TYPE node_cpu_seconds_total counter</span>
node_cpu_seconds_total<span class="token punctuation">{</span>cpu<span class="token operator">=</span><span class="token string">&quot;0&quot;</span>,mode<span class="token operator">=</span><span class="token string">&quot;idle&quot;</span><span class="token punctuation">}</span> <span class="token number">20373.99</span>
node_cpu_seconds_total<span class="token punctuation">{</span>cpu<span class="token operator">=</span><span class="token string">&quot;0&quot;</span>,mode<span class="token operator">=</span><span class="token string">&quot;iowait&quot;</span><span class="token punctuation">}</span> <span class="token number">83.54</span>
node_cpu_seconds_total<span class="token punctuation">{</span>cpu<span class="token operator">=</span><span class="token string">&quot;0&quot;</span>,mode<span class="token operator">=</span><span class="token string">&quot;irq&quot;</span><span class="token punctuation">}</span> <span class="token number">0</span>
node_cpu_seconds_total<span class="token punctuation">{</span>cpu<span class="token operator">=</span><span class="token string">&quot;0&quot;</span>,mode<span class="token operator">=</span><span class="token string">&quot;nice&quot;</span><span class="token punctuation">}</span> <span class="token number">8.43</span>
node_cpu_seconds_total<span class="token punctuation">{</span>cpu<span class="token operator">=</span><span class="token string">&quot;0&quot;</span>,mode<span class="token operator">=</span><span class="token string">&quot;softirq&quot;</span><span class="token punctuation">}</span> <span class="token number">39.88</span>
node_cpu_seconds_total<span class="token punctuation">{</span>cpu<span class="token operator">=</span><span class="token string">&quot;0&quot;</span>,mode<span class="token operator">=</span><span class="token string">&quot;steal&quot;</span><span class="token punctuation">}</span> <span class="token number">0</span>
node_cpu_seconds_total<span class="token punctuation">{</span>cpu<span class="token operator">=</span><span class="token string">&quot;0&quot;</span>,mode<span class="token operator">=</span><span class="token string">&quot;system&quot;</span><span class="token punctuation">}</span> <span class="token number">541.81</span>
node_cpu_seconds_total<span class="token punctuation">{</span>cpu<span class="token operator">=</span><span class="token string">&quot;0&quot;</span>,mode<span class="token operator">=</span><span class="token string">&quot;user&quot;</span><span class="token punctuation">}</span> <span class="token number">691.72</span>

node_cpu_seconds_total<span class="token punctuation">{</span>cpu<span class="token operator">=</span><span class="token string">&quot;1&quot;</span>,mode<span class="token operator">=</span><span class="token string">&quot;idle&quot;</span><span class="token punctuation">}</span> <span class="token number">20385.7</span>
node_cpu_seconds_total<span class="token punctuation">{</span>cpu<span class="token operator">=</span><span class="token string">&quot;1&quot;</span>,mode<span class="token operator">=</span><span class="token string">&quot;iowait&quot;</span><span class="token punctuation">}</span> <span class="token number">77.39</span>
node_cpu_seconds_total<span class="token punctuation">{</span>cpu<span class="token operator">=</span><span class="token string">&quot;1&quot;</span>,mode<span class="token operator">=</span><span class="token string">&quot;irq&quot;</span><span class="token punctuation">}</span> <span class="token number">0</span>
node_cpu_seconds_total<span class="token punctuation">{</span>cpu<span class="token operator">=</span><span class="token string">&quot;1&quot;</span>,mode<span class="token operator">=</span><span class="token string">&quot;nice&quot;</span><span class="token punctuation">}</span> <span class="token number">5.83</span>
node_cpu_seconds_total<span class="token punctuation">{</span>cpu<span class="token operator">=</span><span class="token string">&quot;1&quot;</span>,mode<span class="token operator">=</span><span class="token string">&quot;softirq&quot;</span><span class="token punctuation">}</span> <span class="token number">52.55</span>
node_cpu_seconds_total<span class="token punctuation">{</span>cpu<span class="token operator">=</span><span class="token string">&quot;1&quot;</span>,mode<span class="token operator">=</span><span class="token string">&quot;steal&quot;</span><span class="token punctuation">}</span> <span class="token number">0</span>
node_cpu_seconds_total<span class="token punctuation">{</span>cpu<span class="token operator">=</span><span class="token string">&quot;1&quot;</span>,mode<span class="token operator">=</span><span class="token string">&quot;system&quot;</span><span class="token punctuation">}</span> <span class="token number">536.77</span>
node_cpu_seconds_total<span class="token punctuation">{</span>cpu<span class="token operator">=</span><span class="token string">&quot;1&quot;</span>,mode<span class="token operator">=</span><span class="token string">&quot;user&quot;</span><span class="token punctuation">}</span> <span class="token number">677.49</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>目前围绕 Prometheus 已经有了大量的 Exporter，涵盖了常见的数据库、中间件、硬件等几乎所有需要的收集的对象。</p><table><thead><tr><th>范围</th><th>常用 Exporter</th></tr></thead><tbody><tr><td>数据库</td><td>MySQL Exporter、Redis Exporter、MongoDB Exporter、MSSQL Exporter 等</td></tr><tr><td>硬件</td><td>Apcupsd Exporter、IoT Edison Exporter、IPMI Exporter、Node Exporter 等</td></tr><tr><td>消息队列</td><td>Beanstalkd Exporter、Kafka Exporter、NSQ Exporter、RabbitMQ Exporter 等</td></tr><tr><td>存储</td><td>Ceph Exporter、Gluster Exporter、HDFS Exporter、ScaleIO Exporter 等</td></tr><tr><td>HTTP 服务</td><td>Apache Exporter、HAProxy Exporter、Nginx Exporter 等</td></tr><tr><td>API 服务</td><td>AWS ECS Exporter、Docker Cloud Exporter、Docker Hub Exporter、GitHub Exporter 等</td></tr><tr><td>日志</td><td>Fluentd Exporter、Grok Exporter 等</td></tr><tr><td>监控系统</td><td>Collectd Exporter、Graphite Exporter、InfluxDB Exporter、Nagios Exporter、SNMP Exporter 等</td></tr><tr><td>其它</td><td>Blockbox Exporter、JIRA Exporter、Jenkins Exporter、Confluence Exporter 等</td></tr></tbody></table><h2 id="指标的类型" tabindex="-1"><a class="header-anchor" href="#指标的类型" aria-hidden="true">#</a> 指标的类型</h2><p>监控系统中，虽然我们需要收集的指标可能有成千上万个，但指标类型（Metric Type）却是固定的。Prometheus 定义了如下四种指标类型。</p><h3 id="counter-计数器" tabindex="-1"><a class="header-anchor" href="#counter-计数器" aria-hidden="true">#</a> Counter 计数器</h3><p>这是最好理解的指标类型了，它通过累加求和，计算某个指标总数或者事件发生的次数。比如 QPS、日活月活、销售额等，都属于此类指标。</p><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/prometheus-counter.png" alt=""></p><p>在计数器指标的基础上还可以做进一步的聚合计算处理，比如 Prometheus 支持对计数器指标进行 rate（速率）、top 等计算函数。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>
<span class="token comment"># 通过rate()函数获取HTTP请求量的增长率：</span>
rate<span class="token punctuation">(</span>http_requests_total<span class="token punctuation">[</span>5m<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment"># 查询当前系统中，访问量前10的HTTP地址：</span>
topk<span class="token punctuation">(</span><span class="token number">10</span>, http_requests_total<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="guage-仪表盘" tabindex="-1"><a class="header-anchor" href="#guage-仪表盘" aria-hidden="true">#</a> Guage 仪表盘</h3><p>瞬态仪表盘，主要用来展示系统当前的状态。比如当前的内存使用量，生活中我们开车时的车速就属于此类指标。</p><p>因为此类指标也都是带时间戳的，因此收集后相当于对系统状态的采样集合。虽然单个值只代表当时的系统状态，但却可以根据这些数据做进一步的计算。像 Prometheus 提供了 delta() 函数可用来计算样本在一段时间内的变化情况； predict_linear() 函数可以对未来的值进行预测，比如对磁盘可用空间进行预测，从而提前预警；</p><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/prometheus_guage.webp" alt=""></p><h3 id="histogram-直方图" tabindex="-1"><a class="header-anchor" href="#histogram-直方图" aria-hidden="true">#</a> Histogram 直方图</h3><p>和上述两者都属于数值类的指标不同。直方图和接下来要介绍的 Summary 摘要是统计类型的指标。直方图用来表示指标在不同区间的分布情况。比如上学时，我们按 90 ~ 100，80 ~ 89，70 ~ 79、60 以下等区间来统计成绩分布。</p><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/prometheu_his.webp" alt=""></p><p>需要注意的是，Prometheus 的直方图只有上区间，没有下区间。以 <code>prometheus_http_request_duration_seconds_bucket</code> 为例，其代表请求耗时在不同区间的分布情况。le 为 0.4 是包含了 le 为 0.1 的数据的。也就是说 le 0.1 代表耗时 0 到 0.1s 之间的请求个数；而 le 0.4 则代表耗时 0 到 0.4s 之间的请求个数，如果要求 0.3s ~ 0.4s 之间的请求耗时，需要做相应的运算才行。</p><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/prometheus_his.png" alt=""></p><p>Prometheus 还提供了众多的函数可以对直方图数据做进一步的处理，比如 <code>histogram_fraction()</code> 函数可以用来计算某个区间内的数据占比，我们可以用它来求 P99、P50 等数据；<code>histogram_quantile()</code> 函数可以用来计算某个分位数的值。</p><h3 id="summary-摘要" tabindex="-1"><a class="header-anchor" href="#summary-摘要" aria-hidden="true">#</a> Summary 摘要</h3><p>Summary 也是统计数据的分布情况，但和直方图基于区间统计不同，Summary 计算的是百分比，比如请求的 P90、P99。</p><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/prometheus_summary.webp" alt=""></p><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/prometheus_summary.png" alt=""></p><h2 id="指标的存储" tabindex="-1"><a class="header-anchor" href="#指标的存储" aria-hidden="true">#</a> 指标的存储</h2><p>Prometheus 指标的格式如下：</p><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/prometheus-metrics-format.jpeg" alt=""></p><p>每个指标由四部分组成：</p><ul><li><p><strong>指标名</strong>：表示这个指标是监控哪一方面的状态，比如 http_request_total 表示请求数量，memory_usage 表示内存使用量等。</p></li><li><p><strong>标签集合</strong>：{&lt;label1=v1&gt;,&lt;label2=v2&gt;....}，用来区分指标的表示维度。比如响应是 200 的请求还是 500 的请求；A 服务器的指标还是 B 服务器的指标。</p></li><li><p><strong>时间戳</strong>：描述当前时间序列的时间，单位：毫秒。</p></li><li><p><strong>样本值</strong>：当前监控指标的具体数值。</p></li></ul><p>上述格式组成一个时间序列，其数据集的大小受标签维度的复杂性和采样的实时性影响，很容易导致数据爆炸。</p><p>假设我们有一个小型集群，该集群有 15 个节点，运行着 20 个微服务系统。每个节点需要采集 CPU、GPU、内存、磁盘和网络等资源使用情况，每个服务则需要采集业务相关和中间件相关的指标。假设我们每 5s 采集一次指标，仅 <code>node_memory_MemFree_bytes</code> 一条数据，一天就要采集 <code>15（节点）* 1（指标）* (3600 * 24 / 5)(一天采集次数) = 259,200</code> 条数据。一旦指标数增加，那每天需要采集的数据可能有上亿条，数据大小以 TB 记，这对存储提出了巨大的挑战。</p><p>针对上述时序数据的特点，业界发展出了专门用来存储该类数据的数据库-时序数据库（Time-Series Database，简称 TSDB），通过使用 LSM-Tree 数据结构、数据压缩、定时删除等策略，尽可能的减少要存储的数据量。</p><p>Prometheus 本身就内置了强大的时序数据库，但其也支持配置 InfluxDB 等第三方 TSDB 作为存储后端。</p><h2 id="指标的查询展示与告警" tabindex="-1"><a class="header-anchor" href="#指标的查询展示与告警" aria-hidden="true">#</a> 指标的查询展示与告警</h2><p>Prometheus 提供了 PromSQL 作为查询语言，我们可以通过编写 PromQL 查询来获取和处理监控数据。下面是一些查询实例：</p><ul><li><code>node_memory_MemFree_bytes</code> 查询某个指标的瞬态值。</li><li><code>node_memory_MemFree_bytes{instance=&quot;tk04&quot;}</code> 根据过滤条件查询。</li><li><code>node_memory_MemFree_bytes{instance=~&quot;tk.*&quot;}</code> 根据正则表达式查询。</li></ul><p>Prometheus 还提供了众多函数来对数据做进一步处理，实际工作中可以根据需要使用。</p><p>Prometheus 提供了基本的图形界面用来数据的可视化，但其展示效果一般，因此 Prometheus 官方更推荐使用 Grafana 作为可视化工具，它提供了比较完善的图表选项和 UI 操作，同时针对主流的组件，社区提供了大量的监控大盘模版，通常直接导入使用即可。</p><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/250822-prometheus-monitor-k8s-node.png" alt=""></p><p>除了用于监控大盘展示，指标还需要拿来做告警，用来及时发现系统异常。Prometheus 提供了 Alertmanager 组件来处理告警。我们只需要配置好告警规则，一旦满足条件，Alertmanager 就会发送告警通知。下面是一个告警规则的示例：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> k8s.rules.container_cpu_limits
    <span class="token key atrule">rules</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">expr</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">
        kube_pod_container_resource_limits{resource=&quot;cpu&quot;,job=&quot;kube-state-metrics&quot;}  * on (namespace, pod, cluster)
        group_left() max by (namespace, pod, cluster) (
          (kube_pod_status_phase{phase=~&quot;Pending|Running&quot;} == 1)
        )</span>
      <span class="token key atrule">record</span><span class="token punctuation">:</span> cluster<span class="token punctuation">:</span>namespace<span class="token punctuation">:</span>pod_cpu<span class="token punctuation">:</span>active<span class="token punctuation">:</span>kube_pod_container_resource_limits
    <span class="token punctuation">-</span> <span class="token key atrule">expr</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">
        sum by (namespace, cluster) (
            sum by (namespace, pod, cluster) (
                max by (namespace, pod, container, cluster) (
                  kube_pod_container_resource_limits{resource=&quot;cpu&quot;,job=&quot;kube-state-metrics&quot;}
                ) * on(namespace, pod, cluster) group_left() max by (namespace, pod, cluster) (
                  kube_pod_status_phase{phase=~&quot;Pending|Running&quot;} == 1
                )
            )
        )</span>
      <span class="token key atrule">record</span><span class="token punctuation">:</span> namespace_cpu<span class="token punctuation">:</span>kube_pod_container_resource_limits<span class="token punctuation">:</span>sum
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,47)])])}const u=n(o,[["render",p],["__file","metrics.html.vue"]]);export{u as default};
