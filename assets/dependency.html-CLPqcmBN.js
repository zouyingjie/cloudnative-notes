import{_ as o,r as a,c as s,o as l,a as p,b as n,d as t,e as d}from"./app-C-eiXR-Q.js";const i={},c={href:"https://megaease.cn/zh/docs/monitor/",target:"_blank",rel:"noopener noreferrer"};function f(m,e){const r=a("ExternalLinkIcon");return l(),s("div",null,[e[2]||(e[2]=p('<h1 id="服务依赖管理" tabindex="-1"><a class="header-anchor" href="#服务依赖管理" aria-hidden="true">#</a> 服务依赖管理</h1><p>在微服务架构下，随着服务数量的增加，整个系统的复杂度也在不断地增加。这主要表现在：</p><ul><li>每个服务的资源要求不同</li><li>每个服务的重要程度不同</li><li>每个服务的依赖关系不同</li></ul><p>在服务部署上线之前，必须要梳理清楚服务之间的依赖关系，如果 A 依赖 B，那 B 必须先于 A 部署，否则会导致服务部署启动后无法正常使用的情况。</p><p>依赖关系是分布式服务中比较难以管理的部分，需要合理的业务划分和服务拆分，真正做到服务的高内聚、低耦合。</p><p>在实际工程中，想要彻底做到服务间无依赖是比较难的，我们只能尽量的减少依赖关系。这其中最重要的就是<strong>避免出现依赖环</strong>，这是一种极强的耦合，会导致递归问题，使得服务的部署变得异常复杂。像我们在服务内部编写程序时出现依赖循环时，通常可以采用依赖倒置的原则，引入一个第三方抽象层来解决。对于微服务架构，可以通过事件驱动或者新增第三方服务的方式来解决。</p><p>除了依靠架构师团队基于架构设计和服务实现来手动梳理出服务关系外，还可以通过技术手段实现，比如链路追踪日志会记录请求在每个服务中的调用关系，基于此可以自动化地生成服务的整体拓扑图，下图是一个示例：</p><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/ease.monitor.feature.toplogy.en.png" alt=""></p>',8)),n("p",null,[e[1]||(e[1]=t("图片来自",-1)),n("a",c,[e[0]||(e[0]=t("MegaEase 官网",-1)),d(r)])]),e[3]||(e[3]=n("p",null,"在有了上述拓扑图后，我们可以清晰的知晓整个系统的全局架构，好比有了一张地图，可以帮助我们更好的进行服务的治理和优化。",-1))])}const _=o(i,[["render",f],["__file","dependency.html.vue"]]);export{_ as default};
