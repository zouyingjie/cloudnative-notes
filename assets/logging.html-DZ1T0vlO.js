import{_ as i,r as o,c as l,o as p,a as n,b as r,d as e,e as a,w as g}from"./app-C-eiXR-Q.js";const u={},h={href:"https://github.com/cncf/tag-observability/blob/main/whitepaper.md#logs",target:"_blank",rel:"noopener noreferrer"},c={href:"https://en.wikipedia.org/wiki/Common_Log_Format",target:"_blank",rel:"noopener noreferrer"},b={href:"https://nginx.org/en/docs/http/ngx_http_log_module.html",target:"_blank",rel:"noopener noreferrer"},m={href:"https://logging.apache.org/log4j/2.x/manual/customloglevels.html",target:"_blank",rel:"noopener noreferrer"};function f(k,t){const d=o("ExternalLinkIcon"),s=o("RouterLink");return p(),l("div",null,[t[15]||(t[15]=n('<h1 id="日志" tabindex="-1"><a class="header-anchor" href="#日志" aria-hidden="true">#</a> 日志</h1><h2 id="日志分类" tabindex="-1"><a class="header-anchor" href="#日志分类" aria-hidden="true">#</a> 日志分类</h2><p>日志记录系统运行期间发生的离散事件，在实际工程中，按用途来说大致有三类日志：</p><ul><li><strong>访问日志</strong>：系统每次收到请求时记录的日志。</li><li><strong>应用日志</strong>：开发人员在开发阶段写入的，用来记录系统运行期间发生过的关键离散事件的日志。</li><li><strong>调用链追踪日志</strong>：一次请求在整个系统的完整调用情况，是分布式系统中进行问题排查、性能分析最重要的手段。</li></ul>',4)),r("p",null,[t[1]||(t[1]=e("CNCF 的",-1)),r("a",h,[t[0]||(t[0]=e("可观测性白皮书",-1)),a(d)]),t[2]||(t[2]=e("将日志细化为了五类：",-1))]),t[16]||(t[16]=n("<ul><li><p><strong>应用日志（Application Log）</strong>：应用中的事件日志，帮助开发者理解和 debug 应用。</p></li><li><p><strong>安全日志（Security Log）</strong>：安全相关事件时打印的日志，比如记录登录失败、密码修改、认证失败等事件。</p></li><li><p><strong>系统日志（System Log）</strong>：操作系统内核级别的事件日志。比如系统的 syslog、journald日志 等。</p></li><li><p><strong>审计日志（Audit Log）</strong>：也称为（Audit trail）记录事件的详情，包括事件类型、执行的操作、发起人以及系统响应情况等，用于后续审计分析。</p></li><li><p><strong>基础设施日志（Infrastructure Log）</strong>：涵盖整个基础设施层面的日志收集，包括主机、网络、存储等各个层面的日志。</p></li></ul>",1)),r("p",null,[t[4]||(t[4]=e("这里笔者只对访问日志和应用日志做相关介绍，链路追踪日志在",-1)),a(s,{to:"/cloudnative/observability/05.trace.html"},{default:g(()=>[...t[3]||(t[3]=[e("下一篇链路追踪",-1)])]),_:1}),t[5]||(t[5]=e("讨论。",-1))]),t[17]||(t[17]=r("h2",{id:"访问日志",tabindex:"-1"},[r("a",{class:"header-anchor",href:"#访问日志","aria-hidden":"true"},"#"),e(" 访问日志")],-1)),t[18]||(t[18]=r("h3",{id:"日志格式",tabindex:"-1"},[r("a",{class:"header-anchor",href:"#日志格式","aria-hidden":"true"},"#"),e(" 日志格式")],-1)),r("p",null,[t[7]||(t[7]=e("对于访问日志，工业界标准为来自美国国家超级计算机应用中心（NCSA）的 ",-1)),r("a",c,[t[6]||(t[6]=e("Common Log Format",-1)),a(d)]),t[8]||(t[8]=e("，这也是 Apache 使用的日志格式。标准格式为",-1))]),t[19]||(t[19]=n("<blockquote><p>host ident authuser date request status bytes</p></blockquote><ul><li><strong>host</strong>：客户端主机 IP 或域名</li><li><strong>ident</strong>：客户端标识，大多数时候是 <code>-</code></li><li><strong>authuser</strong>：认证过的用户信息，大多数时候是 <code>-</code></li><li><strong>date</strong>：请求时间，一般放在方括号 [] 中，格式为 <code>[day/month/year:hour:minute:second timezone]</code></li><li><strong>request</strong>：请求信息，包含 HTTP 方法、请求路径、HTTP 版本</li><li><strong>status</strong>：响应状态码</li><li><strong>bytes</strong>：响应体大小，单位为字节</li></ul><p>如果某个字段不存在，则使用 <code>-</code> 代替，示例如下：</p><blockquote><p>127.0.0.1 user-identifier frank [10/Oct/2000:13:55:36 -0700] &quot;GET /apache_pb.gif HTTP/1.0&quot; 200 2326</p></blockquote><p>下面一条是 Apache 的访问日志，可以看到其格式与标准格式基本一致：</p><blockquote><p>192.168.2.20 - - [28/Jul/2006:10:27:10 -0300] &quot;GET /cgi-bin/try/ HTTP/1.0&quot; 200 3395</p></blockquote>",6)),r("p",null,[t[10]||(t[10]=e("Nginx 的日志格式基本遵循这个规范，但也做了一些扩展。比如增加了 HTTP Referer 和 User Agent 这样的信息，具体参考 Nginx 文档：",-1)),r("a",b,[t[9]||(t[9]=e("## ngx_http_log_module",-1)),a(d)]),t[11]||(t[11]=e(" 其默认格式为",-1))]),t[20]||(t[20]=n(`<div class="language-nginx line-numbers-mode" data-ext="nginx"><pre class="language-nginx"><code>  <span class="token directive"><span class="token keyword">log_format</span>   main <span class="token string">&#39;<span class="token variable">$remote_addr</span> - <span class="token variable">$remote_user</span> [<span class="token variable">$time_local]</span>  <span class="token variable">$status</span> &#39;</span>
    <span class="token string">&#39;&quot;<span class="token variable">$request</span>&quot; <span class="token variable">$body_bytes_sent</span> &quot;<span class="token variable">$http_referer</span>&quot; &#39;</span>
    <span class="token string">&#39;&quot;<span class="token variable">$http_user_agent</span>&quot; &quot;<span class="token variable">$http_x_forwarded_for</span>&quot;&#39;</span></span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>无论是用 Nginx/Apache 还是 Web 服务器、服务框架，生成的访问日志一般需要包含以下信息：</p><table><thead><tr><th>字段名</th><th>含义</th></tr></thead><tbody><tr><td>来源主机</td><td>发出请求的客户端的 IP 或者域名 。如果无法获取则使用 <code>-</code> 代替</td></tr><tr><td>访问用户</td><td>客户端用于验证身份的用户名或用户 ID。如果不存在值则使用 <code>-</code> 代替</td></tr><tr><td>访问时间</td><td>请求的时间，格式为 <code>[day/month/year:hour:minute:second timezone]</code> ，比如 <code>[07/Aug/2024:05:48:44 +0000]</code>。通常即使天数日期为一位数，也用两位表示，比如 <code>07</code> 而不是 <code>7</code>。</td></tr><tr><td>请求信息</td><td>包含请求的方法、请求的路径、请求的协议</td></tr><tr><td>响应状态码</td><td>响应状态码，比如 200、404</td></tr><tr><td>响应字节数</td><td>响应体大小，单位为字节</td></tr><tr><td>响应时间</td><td>执行请求的耗时，单位为毫秒</td></tr><tr><td>TraceID（可选）</td><td>请求的 TraceID</td></tr><tr><td>SpanID（可选）</td><td>请求的 SpanID</td></tr><tr><td>ParentSpanID（可选）</td><td>请求的父 SpanID，如果当前请求是链路中的第一个请求，则使用 <code>-</code> 代替</td></tr><tr><td>headers（可选）</td><td>请求、响应头中的信息，比如 <code>User-Agent</code>、<code>Referer</code> 等，按需选择，注意不要包含认证 token 等敏感信息</td></tr></tbody></table><h3 id="日志聚合" tabindex="-1"><a class="header-anchor" href="#日志聚合" aria-hidden="true">#</a> 日志聚合</h3><p>基于以上格式，可以看到访问日志中包含了请求路径、请求方法、请求的返回状态码、响应时间等信息，基于这些信息做聚合就可以计算出如下关键指标：</p><ul><li><strong>吞吐量指标</strong>：如 m1_rate，m5_rate，m15_rate。即 1 分钟、5 分钟、15 分钟内的 QPS。</li><li><strong>响应时间统计</strong>：计算出 P50、P95、P99 等时间分布统计。</li><li><strong>状态码分布指标</strong>：统计不同状态码的请求数量，分析系统错误情况，当 4XX、5XX 错误率较高时，需要及时告警，分析原因。</li><li><strong>TopN 请求</strong>：可以统计访问量最大、访问最慢、错误最多的请求，然后做针对性的分析优化。</li></ul><h2 id="应用日志" tabindex="-1"><a class="header-anchor" href="#应用日志" aria-hidden="true">#</a> 应用日志</h2><p>应用日志主要记录系统运行期间发生过的离散事件，用于在分析故障问题时提供上下文，帮助快速定位问题，因此也被称为诊断日志。</p><h3 id="日志格式-1" tabindex="-1"><a class="header-anchor" href="#日志格式-1" aria-hidden="true">#</a> 日志格式</h3><p>应用日志目前没有业界统一的规范，更多的来自于实践反馈。下面是一个参考格式</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>[时间戳] [日志级别] [模块名] [进程ID] [线程ID] [TraceID | SpanID | ParentSpanID]  [错误码] [错误信息] [文件名] [文件行号]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>时间戳</strong></p><p>日志产生的时间戳，一般取应用所在机器的本地时间，精确到毫秒。格式为 <code>[yyyy-MM-dd HH:mm:ss.SSS]</code>。</p><p><strong>日志级别</strong></p><p>标识日志的重要程度，由高到低通常为 错误（ERROR）、警告（WARN）、信息（INFO）、调试（DEBUG）四类，分别用于：</p><ul><li>ERROR：记录错误、异常信息。通常需要立即告警、修复。</li><li>WARN：记录警告信息，比如非致命错误、潜在问题、不当用法等。通常需要引起后续的关注和消除。</li><li>INFO：记录应用运行过程的关键事件，比如操作信息、启动过程、配置变更信息等。</li><li>DEBUG：用于错误分析的调试信息，通常只在开发、调试阶段使用。如果生产需要，也可以动态的将部分日志界别调整到 DEBUG。</li></ul>`,16)),r("p",null,[t[13]||(t[13]=e("更细分的日志级别可以参考 ",-1)),r("a",m,[t[12]||(t[12]=e("log4j",-1)),a(d)]),t[14]||(t[14]=e("，其有如下等级：",-1))]),t[21]||(t[21]=n('<table><thead><tr><th>日志级别</th><th>含义</th></tr></thead><tbody><tr><td>ALL</td><td>打印所有日志</td></tr><tr><td>TRACE</td><td>更细粒度的 debug 日志，通常在开发、调试阶段使用</td></tr><tr><td>DEBUG</td><td>用于输出详细的调试信息，比如函数的入参、返回值，事件的详细信息等。</td></tr><tr><td>INFO</td><td>记录关键事件，比如重要状态的变化、系统启动、服务运行期间的重要事件等。</td></tr><tr><td>WARN</td><td>记录警告信息，比如非致命错误、潜在问题、不当用法等。</td></tr><tr><td>ERROR</td><td>记录错误信息，比如系统错误、异常信息等。</td></tr><tr><td>FATAL</td><td>记录致命错误信息，比如程序崩溃、系统宕机等。</td></tr><tr><td>OFF</td><td>最高级别，用于关于日志</td></tr></tbody></table><p>大部分情况下，生产环境中日志级别使用 INFO 即可，TRACE 和 DEBUG 信息量太大，除了少数关键核心业务，不建议在生产环境中使用。另外在打印 Error/Fatal 级别的日志时，通常需要伴随着事件告警，及时通知相关人员处理错误。</p><p><strong>模块名</strong></p><p>通常是服务名，标识日志所在的业务和服务模块。比如是商户服务、订单服务等。</p><p><strong>进程ID/线程 ID</strong></p><p>日志所属进程和线程的ID，通常为应用的进程ID 或进程名。</p><p><strong>TraceID/SpanID/ParentSpanID</strong></p><p>请求的 TraceID、SpanID、ParentSpanID，如果当前日志与请求无关，则使用 <code>-</code> 代替。</p><p><strong>错误码/错误信息</strong></p><p>错误码，如果当前日志与错误无关，则使用 <code>-</code> 代替。</p><p><strong>文件名/文件行号</strong></p><p>产生日志的文件名和行号，通常为应用代码的文件名和行号。</p><h3 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项" aria-hidden="true">#</a> 注意事项</h3><ul><li><p>想清楚目的后再打印日志，避免<strong>打印一切</strong>的冲动，日志打印代码本身会消耗资源、影响性能；过多的日志也需要更多的存储空间和更高的查询时间。</p></li><li><p>只打印关键信息，比如追踪诊断信息、重要事件（比如账户金额变更）、启动时输出配置信息等。</p></li><li><p>避免打印敏感信息，比如请求中的 token，用户的敏感信息。</p></li><li><p>日志信息的描述要清晰简洁，方便后续的阅读分析。</p></li><li><p>日志数据收集清晰后需要进行统一存储，并提供<strong>基于关键字的上下文查询</strong>，方便后续的分析。</p></li><li><p>通常日志数据的时效性较低且数据量较大，因此要定期 rotate，将旧的日志数据做清理或归档。如果归档，可以采用冷热架构，将旧的日志数据归档到冷存储中，以节省存储成本。</p></li></ul><h2 id="日志存储" tabindex="-1"><a class="header-anchor" href="#日志存储" aria-hidden="true">#</a> 日志存储</h2><p>在日志存储领域，ElasticSearch 是一个广泛使用的解决方案，几乎已经是事实上的标准，接触过的同学相信一定对术语 ELK（ElasticSearch、Logstash、Kibana） 不陌生，它们都是 ElasticSearch 公司的产品，加上其用于收集指标日志的 Beats 系列组件，形成了一套完整的日志处理解决方案。</p><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/elasticsearch-elk.png" alt=""></p><p>上述技术栈的核心就是 ElasticSearch，其诞生和发展历程也是一个传奇。据说创始人 Shay Banon 是为了要当厨师的妻子开发一个方便搜索菜谱的应用接触了 Apache Lucene，但因为 Lucene 的使用门槛较高，于是 Shay Banon 便在 Lucene 的基础上不断开发优化，最终推出了 ElasticSearch，并且成立公司后在 2018 年上市，市值达到 50 亿美元，实在是技术人之楷模。</p><h3 id="倒排索引-inverted-index" tabindex="-1"><a class="header-anchor" href="#倒排索引-inverted-index" aria-hidden="true">#</a> 倒排索引 Inverted index</h3><p>Apache Lucene 使用倒排索引来实现高效的全文检索。我们以书籍为例介绍下倒排索引，在大部头教科书中，一般会有两种方便我们快速查找内容的索引：</p><ul><li><strong>目录</strong>：章节和页码的对应关系。</li><li><strong>索引</strong>：关键词和页码的对应关系。</li></ul><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/elk-index.png" alt=""></p><p>书的目录就是类似于正排索引，代表文档 ID 到内容的映射。</p><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/elk-index-04.pic.jpg" alt=""></p><p>倒排索引相当于书的索引，是内容到文档 ID 的映射。</p><p><img src="https://pub-08b57ed9c8ce4fadab4077a9d577e857.r2.dev/elk-index-03.pic.jpg" alt=""></p><p>倒排索引的核心有两部分：</p><ul><li>分词词典（Term Dictionary）：分词后的关键词词典以及关键词到倒排列表项的关联信息。</li><li>倒排列表（Posting List）：记录关键词所关联文档的位置信息。</li></ul><p>这样在查询的时候，通过关键词获取到倒排列表项，然后根据倒排列表项中文档 ID 的位置信息，就可以快速定位到具体的文档内容，从而实现全文检索。</p><h3 id="lsm-tree" tabindex="-1"><a class="header-anchor" href="#lsm-tree" aria-hidden="true">#</a> LSM Tree</h3>',30))])}const x=i(u,[["render",f],["__file","logging.html.vue"]]);export{x as default};
