# CICD 实践指南

CI/CD 指的是 **Continuous Integration（持续集成）** 和 **Continuous Delivery（持续交付）**，从实践来看应该还有 **Continuous Deployment（持续部署）** 这一步。我们先来区分下这三者的区别：

- **持续集成(Continuous Integration)** ：持续集成关注的是将开发人员的代码不断集成到代码库中。为了保证新的代码没有问题，我们需要在开发人员提交代码后，执行代码编译、质量审查、单元测试等操作，如果期间遇到问题需要通知开发人员进行修正，在没有问题后进行构建打包，并将制品（二进制文件、镜像）推送到制品库中。

- **持续交付(Continous Delivery)**：持续交付是将集成后的代码部署到更贴近真实运行环境的「类生产环境」(production-like environments) 中。在这里可以进行更进一步的功能测试、性能压测以及契约测试等，如果有单独的测试团队，通常也是在这个环境进行测试工作。如果测试没有问题，就可以准备自动或者手动部署到生产环境中。

- **持续部署(Continous Deployment)**：在持续交付的基础上，把部署到生产环境的过程自动化。

虽然功能有所不同，但上述三步强调的都是自动化，做到自动化编译构建，自动化测试，自动化审查，自动化部署。

## 持续集成

### 持续集成的要点

下面是一些业界普遍认同的原则：

1. 需要有**专门的集成服务器**执行 CI 操作。
   
2. 根据项目需要，集成操作应该支持基于代码变化（比如 push，PR 合并）的自动触发、定时执行或者手动触发。

3. 提交到代码库的代码必须是可以正常运行、符合规范的，这需要在构建过程执行单元测试、代码审查等操作。

4. 必须保证构建最终成功。如果构建过程中出现错误，修复此类错误是**优先级最高的任务**。在修复后需要重新执行构建。

5. 构建后生成的制品需要存入制品库（Maven 仓库、镜像仓库）等，并部署到集成测试环境。

6. 在集成测试环境需要进行一系列的自动化功能测试。测试需要覆盖核心的业务流程以及关键功能点。

7. 可以在集成测试环境运行相关的性能测试，做初步的性能诊断。


## 编译打包规范

开发人员提交的代码必须是能编译通过并经过代码排查，下面是一些编译打包的规范：

- 编译环境必须是干净的，不能有任何残留的编译产物。
- 每次编译都是独立的，应该从代码库拉取最新代码开始。
  
- 尽量使用容器化的编译环境，因为容器化编译环境每次都是重新实例化,是一个纯净的环境。物理机器在多次编译及操作后,可能编译环境变量和版本信息发生了变更。而且容器化后可以隔离环境的不同,按需启动,减少资源占用。

- 对于各类语言，尽量维持统一的编译环境标准，比如使用统一的 Java/Linux 基础镜像。特殊环境需求需要经过申请和审核。

- 所有的编译告警都应该处理,如果确保是正确的，应该通过其他手段去掉告警信息。
  
- 开发人员更了解代码功能及需求，应该尽可能由开发定义自动编译脚本，脚本中如果有编译开关选项，需要明确定义写明注释。

- 编译服务器的资源要足够，避免因资源不足导致的编译失败和任务阻塞。
  
- 对于 maven/npm 等，尽可能用官方的仓库。如需要使用私有库，需要建立严格的管理制度，对提交入库的包严格测试。一般可以使用 Nexus 这类工具，作为私有仓库和代理，
  代理官方仓库的包，避免每次编译都需要从外部下载，加快编译速度。

- 编译产物需要存入制品库，制品库可以是 Maven 仓库、Docker 镜像仓库等。

### 镜像标记规范

鉴于容器化编译环境的普及，编译产物通常是 Docker 镜像。为了便于管理和追踪，镜像需要使用合理的命名和标记规范。

Docker 映像由两个部分标识：名称和标记。例如 ``namespace/service-name:1.9.3`` 镜像,``namespace/service-name`` 是其名称，``1.9.3`` 是其标记。如果在构建镜像时没有明确制定标记,则系统默认使用 ``latest`` 标记。

在企业内部，通常可以把 namespace 分给不同的业务域, 以业务域的名称来命名。服务名即服务在服务目录(CMD或配置中心)的名称，而标记代表版本号。

关于标记，通常有以下几种方式进行标记：

**语义化版本控制**

语义化版本控制（Semantic Versioning）是一种常用的版本标记方式，通常格式为 `MAJOR.MINOR.PATCH`。其中：

- `MAJOR`：主版本号，仅在发布了不兼容的 API 修改时递增。
  
- `MINOR`：次版本号，通常在发布了新功能时递增。
  
- `PATCH`：补丁版本号，通常在做了 bug 修复时递增。

后两个版本号的递增必须在不破坏向后兼容性的前提下进行。使用语义化版本控制时：

- 始终使用 ``latest`` 标记最新的稳定版本的镜像，一般每次发布新版本时都会更新 ``latest`` 标记。
  
- X.Y.Z 版本号的镜像可以用来标记特定版本的镜像，方便用户下载和使用。

**Git 哈希标识**

另一种常用的标记方式是使用 Git 提交的哈希值。每次提交都会生成一个唯一的哈希值，可以用来标记镜像。通常格式为 `commit-id`，例如 `abc1234`。这种方式可以快速定位镜像对应的代码提交，方便追踪和回溯。

**混合标记**

如果 CICD 流水线支持获取更加丰富的信息，可以考虑使用混合标记的方式。比如版本号、Git 提交哈希、分支和构建时间等信息，也可以通过自定义 label 进行更加精细化的管理。

笔者常用的发布流水线就采用了混合标记的方式，因为每次构建的分支是固定的，因此采用了 ``version-commitID-buildTime`` 格式进行标记。比如``v3.0.0-ae2bb521a-230528161535`` 表示构建的软件版本为 `v3.0.0`，对应的代码提交为 `ae2bb521a`，构建时间为 `2023-05-28 16:15:35`，

### 代码审查规范

代码审查目的在于提高整体代码品质，提前暴露代码中隐藏的风险，对代码采用静态分析工具执行审查已经成为普遍共识。

常用工具包括 SonarQube、Checkstyle、PMD 等。首先开发人员最好在本地的 IDE 中集成相应的审查工具，像 IDEA、VSCode 都有相关的插件，做到在开发时就能发现问题。

其次我们需要将代码审查集成到 CI/CD 流程中，确保每次代码提交都经过审查。另外我们还需要定期生成代码审查报告。

代码审查的内容包括但不限于以下几个方面：

- **编程规范**：变量、函数命名规范，缩进，格式、注释等。
- **代码可读性**：命名、注释、代码尺寸、程序逻辑简化、状态控制、统一标准化。
- **可维护性**：抽象（模型、数据和流程）、耦合度、重用性。
- **错误处理**：错误逻辑、分级、处理以及相关的日志报警。
- **安全漏洞**：SQL 注入、输入输出检查、数组越界、敏感信息、外部引用安全性、安全规则和安全漏洞检查等。
- **内存泄露**：是否有范围越界，资源未释放等。
- **性能问题**：语言性能、并发问题、中间件使用、数据库操作 SQL 等。
- **代码重复率**：冗余代码，相同代码的出现频率。
- **测试覆盖率**：关键逻辑的单元测试。


## 持续交付

### 单元测试

### 功能测试

### 契约测试

### 性能测试


## 持续部署

### 部署规范

在大型分布式微服务架构中，系统之间存在依赖和耦合，因此为了保证部署的稳定性，需要遵循一定的部署策略和发布流程。

#### 部署前准备





### 部署策略